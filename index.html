<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>üéµ Absolute Pitch Trainer</title>
<link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&display=swap" rel="stylesheet">
<style>
  :root { --bg:#0f172a; --card:#1e293b; --muted:#334155; --good:#16a34a; --bad:#dc2626; --text:#e5e7eb; --accent:#fbbf24; --neutral:#94a3b8; --muted2:#2a3a54; }
  *{box-sizing:border-box}
  body{font-family:'Fredoka',sans-serif;background:var(--bg);color:var(--text);margin:0;padding:20px}
  .card{max-width:1060px;margin:auto;background:var(--card);border-radius:20px;padding:20px;box-shadow:0 10px 30px rgba(0,0,0,.15)}
  h1,h2,h3{margin:0 0 8px}
  button{margin:6px;padding:10px 16px;border-radius:12px;border:none;cursor:pointer;font-size:14px;background:var(--muted);color:var(--text);transition:transform .06s ease, filter .12s ease, background .12s ease, border-color .12s ease}
  button:hover{transform:translateY(-1px)}
  button:active{transform:translateY(0)}
  button:disabled{opacity:.55; cursor:not-allowed; background:var(--muted2); border:1.5px dashed var(--muted)}
  input,select{padding:10px 12px;border-radius:12px;border:1px solid var(--muted);background:var(--card);color:var(--text)}
  select{appearance:none;background-image:linear-gradient(45deg,transparent 50%,var(--text) 50%),linear-gradient(135deg,var(--text) 50%,transparent 50%),linear-gradient(to right,transparent,transparent);
         background-position:calc(100% - 20px) 16px, calc(100% - 14px) 16px, 100% 0; background-size:6px 6px,6px 6px, 2.5em 2.5em; background-repeat:no-repeat}
  label{opacity:.9}
  .screen{display:none}
  .pill{display:inline-flex;align-items:center;background:var(--muted);padding:8px 12px;border-radius:16px;font-size:13px;margin:6px;white-space:nowrap}
  .pill.clickable{cursor:pointer;transition:background 0.2s ease}
  .pill.clickable:hover{background:var(--muted2);transform:translateY(-1px)}

  /* Tooltip system for UI pills */
  .tooltip{position:relative}
  .tooltip-content{position:absolute;bottom:110%;left:50%;transform:translateX(-50%);background:var(--card);border:1px solid var(--muted);color:var(--text);padding:8px 12px;border-radius:8px;font-size:12px;white-space:nowrap;z-index:1000;opacity:0;visibility:hidden;transition:opacity 0.3s,visibility 0.3s;box-shadow:0 4px 12px rgba(0,0,0,0.3);max-width:300px;white-space:normal;line-height:1.4}
  .tooltip:hover .tooltip-content{opacity:1;visibility:visible}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .note-pad{display:grid;grid-template-columns:repeat(3,1fr);gap:12px;margin-top:12px}
  .note{min-height:64px;font-size:18px;border-radius:14px}
  .note.inert{background:var(--muted2) !important; border:1.5px dashed var(--muted); cursor:not-allowed}
  .wide{grid-column:1 / -1}
  #barStatus{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin-bottom:8px}
  #barControls{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  #feedbackOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;pointer-events:none}
  #feedbackBox{min-width:240px;text-align:center;padding:16px 18px;border-radius:14px;font-weight:700;font-size:20px;box-shadow:0 20px 60px rgba(0,0,0,.35);transform:scale(.9);opacity:0;transition:transform .15s,opacity .15s}
  #feedbackOverlay.show #feedbackBox{transform:scale(1.05);opacity:1}

  #bootError{display:none;position:fixed;left:12px;right:12px;bottom:12px;background:var(--bad);color:var(--text);padding:10px 12px;border-radius:10px;box-shadow:0 4px 18px rgba(0,0,0,.35);z-index:9999;font:13px/1.35 system-ui,sans-serif;white-space:pre-wrap}

  /* Flappy */
  #flappyModal{position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;align-items:center;justify-content:center;z-index:50}
  #flappyCanvas{background:var(--card);width:320px;height:480px;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.35);cursor:pointer;-webkit-tap-highlight-color:transparent;touch-action:none;user-select:none;-webkit-user-select:none;-webkit-touch-callout:none;outline:none}

  input[type="range"].disabled{opacity:.4;filter:grayscale(1)}

  /* Suggestion banner */
  #suggestBanner{display:none;margin:8px 0 4px;padding:10px 12px;border-radius:12px;background:var(--muted2);border:1px solid var(--muted);color:var(--text);align-items:center;gap:10px}
  #suggestBanner button{margin:0 4px;padding:8px 12px;border-radius:10px;font-size:13px}
  #btnRestartSet{background:var(--good)}
  #btnDismissSuggest{background:var(--muted)}

  /* Modals */
  #strictModal,#welcomeModal,#newPitchModal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:1000;background:rgba(0,0,0,.55);pointer-events:auto}
  #strictBox,#welcomeBox,#newPitchBox{width:min(760px,92vw);background:var(--card);border:1px solid var(--muted);border-radius:16px;padding:18px 20px;box-shadow:0 20px 60px rgba(0,0,0,.5)}
  #strictBox h3,#welcomeBox h2,#newPitchBox h2{margin:0 0 8px}
  #strictBtns,#welcomeBtns,#newPitchBtns{display:flex;gap:10px;justify-content:flex-end;margin-top:12px}
  #btnStrictResume{background:var(--good)}
  #btnStrictMenu{background:var(--muted)}
  #welcomeBtns button{background:var(--muted)}
  #btnHearNewPitch{background:var(--accent);color:var(--bg);font-weight:700}
  #btnContinueTraining{background:var(--good)}
  #tutorialWrap{background:var(--card);border:1px solid var(--muted);border-radius:12px;padding:12px;margin:10px 0}

  /* Progress (charts) */
  #progressCard{margin-top:14px}
  #progressControls{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin-bottom:8px}
  #progressLegend{display:flex;gap:12px;align-items:center;font-size:13px;opacity:.9}
  .legendDot{width:12px;height:12px;border-radius:50%}

  /* Tutorial pager */
  .tPage{display:none}
  .tPage.active{display:block}
  #tutorialNav{display:flex;gap:8px;justify-content:space-between;margin-top:10px}
  #tBack{visibility:hidden}

  /* Special exercise strip */
  #specialBar{display:none;align-items:center;justify-content:space-between;background:var(--muted2);border:1px solid var(--muted);color:var(--text);padding:8px 12px;border-radius:10px;margin-bottom:10px}

  /* Scope picker CTA styling */
  .scopeWrap{display:flex;align-items:center;gap:8px;padding:6px 8px;border-radius:12px;background:var(--muted2);border:1px solid var(--muted)}
  .scopeWrap:hover{box-shadow:0 0 0 2px rgba(251,191,36,.25) inset}
  .scopeSelect{background:var(--card);border:1.5px solid var(--muted);border-radius:10px;padding:8px 36px 8px 10px;font-weight:600}
  .scopeSelect:focus{outline:none; box-shadow:0 0 0 2px var(--accent)}
  .scopeBtn{background:var(--accent);color:var(--bg);font-weight:700}
</style>
</head>
<body>
  <!-- Start -->
  <div class="card screen" id="startScreen">
    <h1>Welcome!</h1>
    <p>Enter your name to begin:</p>
    <input id="userNameInput" placeholder="Your name" />
    <button id="startBtn">Start ‚ñ∂</button>
  </div>

  <!-- Welcome / Tutorial -->
  <div id="welcomeModal" aria-modal="true" role="dialog">
    <div id="welcomeBox" class="card">
      <h2>üìò How this program works</h2>
      <div id="tutorialWrap">
        <div class="tPage active" id="tPage1">
          <h3>üéØ Goal</h3>
          <p>Learn to recognize the <strong>12 pitches</strong> by ear (C, C#/Db, D, D#/Eb, E, F, F#/Gb, G, G#/Ab, A, A#/Bb, B). You start with a single pitch and add more.</p>
          <ul>
            <li><strong>Unlock order (study):</strong> alternate semitones around F: <strong>F, E, F#/Gb, Eb, G, D, Ab, Db, A, C, Bb, B</strong>.</li>
            <li>Training uses <strong>sets</strong> (how many pitches you‚Äôre learning) and <strong>blocks</strong> (24 per set).</li>
            <li><strong>RT (reaction time)</strong> = max time to answer; it increases slightly with set size.</li>
          </ul>
        </div>
        <div class="tPage" id="tPage2">
          <h3>‚è± Daily session</h3>
          <ul>
            <li>Train for <strong>30 minutes</strong> (timer runs only while actively training).</li>
            <li><strong>60-second breaks after each 6-minute block</strong> with Flappy.</li>
            <li>Menus and Flappy don't count toward training time.</li>
            <li>Blocks <strong>1‚Äì20</strong> with feedback; <strong>21‚Äì24</strong> are tests (no feedback).</li>
          </ul>
        </div>
        <div class="tPage" id="tPage3">
          <h3>üéπ Octaves (per study)</h3>
          <ul>
            <li>Training tones span <strong>Octaves 3‚Äì5 (C3‚ÄìC5)</strong> with performance-based mixing.</li>
            <li><strong>All audio types:</strong> C3‚ÄìC5 range ‚Ä¢ <strong>Adaptive:</strong> Center/neighbor balance</li>
            <li>This encourages learning the <em>chroma</em> (pitch class), not just pitch height.</li>
            <li>Tone length: <strong>800 ms</strong> with optional jitter for boundary training.</li>
          </ul>
        </div>
        <div class="tPage" id="tPage4">
          <h3>üß™ Special exercises (Block 15)</h3>
          <ul>
            <li>When you‚Äôre learning <strong>‚â• 5 pitches</strong>, Block 15 becomes specials:</li>
            <li><strong>Exercise A</strong>: 12 trials with feedback ‚Äî <em>Target (pitch)</em> vs <em>Other (¬±2 semitones)</em>.</li>
            <li><strong>Exercise B</strong>: 22 trials without feedback ‚Äî same task.</li>
          </ul>
        </div>
        <div class="tPage" id="tPage5">
          <h3>üê§ Flappy breaks</h3>
          <ul>
            <li>Reward mini-game; every flap plays a random pitch.</li>
            <li>Timer stays paused until you press <strong>Play</strong> again.</li>
          </ul>
        </div>
        <div class="tPage" id="tPage6">
          <h3>üìä Assessment Test</h3>
          <ul>
            <li><strong>Purpose:</strong> Measure your absolute pitch ability with 20 random pitches across different audio types.</li>
            <li><strong>When to take:</strong> At the start and end of your 8-week program, or weekly to track progress.</li>
            <li><strong>Features:</strong> No feedback during test, results saved to tracker for progress monitoring.</li>
            <li>View your assessment history and progress in the <strong>Track</strong> section from the main menu.</li>
          </ul>
        </div>
      </div>
      <div id="welcomeBtns">
        <div id="tutorialNav" style="width:100%">
          <button id="tBack">‚óÄ Back</button>
          <div style="flex:1"></div>
          <button id="tNext">Next ‚ñ∂</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Menu -->
  <div class="card screen" id="menuScreen">
    <h1 id="greeting">Absolute Pitch Trainer</h1>
    <div class="row">
      <span class="pill" id="capInfo">Left: 20:00</span>
      <span class="pill" id="weekPill">This week: 0 hrs 0 mins</span>
      <span class="pill" id="lockoutPill" style="display:none">üîí Locked</span>
    </div>
    <div class="row">
      <button id="menuStart">‚ñ∂ Start Training</button>
      <button id="startAssessment">üìä Assessment Test</button>
      <button id="viewTracker">üìä Track</button>
      <button id="exportData">üì§ Export Data</button>
      <button id="playFlappy">üê§ Flappy (lockout only)</button>
      <button id="resetLockout">‚ö° Reset lockout/timer</button>
      <button id="menuReset">‚ü≤ Reset (factory)</button>
      <button id="debugToggle" style="opacity:0.6;font-size:11px;display:none;">Debug</button>
    </div>
    
    <!-- Debug panel -->
    <div id="debugPanel" style="display:none;margin-top:12px;padding:10px;background:var(--muted2);border-radius:8px;font-size:11px;font-family:monospace;">
      <div id="debugContent">Debug info will appear here...</div>
    </div>

    <!-- Scope looks obviously changeable now -->
    <div class="row" style="margin-top:8px;gap:12px">
      <div class="scopeWrap">
        <span style="opacity:.9">Current scope:</span>
        <select id="setSizeSelect" class="scopeSelect"></select>
        <button id="applySetBtn" class="scopeBtn">Change‚Ä¶</button>
      </div>
    </div>
    
    <!-- Audio Selection -->
    <div class="row" style="margin-top:8px;gap:12px">
      <div class="scopeWrap">
        <span style="opacity:.9">Audio type:</span>
        <select id="audioTypeSelect" class="scopeSelect">
          <option value="piano">Piano (C3-C5)</option>
          <option value="sine">Sine Wave (C3-C5)</option>
          <option value="guitar">Guitar (C3-C5)</option>
        </select>
        <button id="applyAudioBtn" class="scopeBtn">Change</button>
      </div>
    </div>
    
    <!-- Timbre Variety Mode -->
    <div class="row" style="margin-top:8px;gap:12px">
      <div class="scopeWrap">
        <span style="opacity:.9">Variety mode:</span>
        <label style="display: flex; align-items: center; gap: 8px;">
          <input type="checkbox" id="varietyModeToggle" style="margin: 0;">
          <span id="varietyModeLabel">Will activate after week 3</span>
        </label>
        <button id="varietyInfoBtn" class="scopeBtn" style="padding: 8px 12px;">?</button>
      </div>
    </div>
    
    <!-- Theme Selection -->
    <div class="row" style="margin-top:8px;gap:12px">
      <div class="scopeWrap">
        <span style="opacity:.9">Theme:</span>
        <select id="themeSelect" class="scopeSelect">
          <option value="default">Dark Ocean</option>
          <option value="beach">Beach Sunset</option>
          <option value="jungle">Jungle Canopy</option>
          <option value="sky">Cloud Nine</option>
          <option value="desert">Desert Oasis</option>
          <option value="neon">Neon Nights</option>
          <option value="forest">Mystic Forest</option>
        </select>
        <button id="applyThemeBtn" class="scopeBtn">Change</button>
      </div>
    </div>

    <!-- Progress -->
    <div class="card" id="progressCard">
      <h3>üìà Progress</h3>
      <div id="progressControls">
        <label for="pitchSelect">Pitch:</label>
        <select id="pitchSelect" style="padding-right:28px"></select>
        <label for="granularitySelect">View:</label>
        <select id="granularitySelect" style="padding-right:28px">
          <option value="WEEKLY" selected>Weekly (Day 1 ‚Üí 7)</option>
          <option value="OVERALL">Overall (Week 1 ‚Üí 8)</option>
        </select>
        <div id="progressLegend">
          <span class="legendDot" style="background:var(--good)"></span> <span id="legGood">Correct %</span>
          <span class="legendDot" style="background:var(--bad);margin-left:12px)"></span> <span id="legBad">Incorrect %</span>
          <span class="legendDot" style="background:var(--neutral);margin-left:12px)"></span> <span id="legTrend">No-trial day</span>
        </div>
      </div>
      <canvas id="progressCanvas" width="1000" height="300" style="width:100%;height:auto;border-radius:12px;background:var(--card);border:1px solid var(--muted)"></canvas>
    </div>
  </div>

  <!-- Assessment Tracker Screen -->
  <div class="card screen" id="trackerScreen">
    <h1>üìä Assessment Tracker</h1>
    <div class="row">
      <span class="pill" id="trackerCount">0 assessments</span>
      <button id="btnBackMenuTracker">‚Ü© Menu</button>
    </div>
    
    <div style="margin:20px 0">
      <div id="trackerLegend" style="display:flex;gap:12px;align-items:center;font-size:13px;opacity:.9;margin-bottom:12px">
        <span class="legendDot" style="background:var(--good)"></span> <span>Exact Correct %</span>
        <span class="legendDot" style="background:var(--accent);margin-left:12px"></span> <span>Within ¬±1 semitone %</span>
      </div>
      <canvas id="trackerCanvas" width="1000" height="300" style="width:100%;height:auto;border-radius:12px;background:var(--card);border:1px solid var(--muted)"></canvas>
    </div>
    
    <div id="trackerDetails" style="margin-top:16px">
      <h3>Assessment History</h3>
      <div id="trackerHistory" style="max-height:200px;overflow-y:auto;border:1px solid var(--muted);border-radius:12px;padding:12px;background:var(--card)">
        <p style="opacity:0.7;text-align:center">No assessments completed yet</p>
      </div>
    </div>
  </div>

  <!-- Trainer -->
  <div class="card screen" id="trainerScreen">
    <div id="specialBar" class="row">
      <span id="specialText">Special Exercise</span>
      <span class="pill" id="specialCount">0 / 0</span>
    </div>

    <div id="suggestBanner" class="row">
      <span>Struggling in the test phase. Restart this pitch set?</span>
      <div style="margin-left:auto"></div>
      <button id="btnRestartSet">Restart set</button>
      <button id="btnDismissSuggest">Dismiss</button>
    </div>

    <div id="barStatus">
      <span class="pill" id="promptPill">Press Play to start</span>
      <span class="pill" id="setInfo">Pitches 1 / 12</span>
      <span class="pill" id="blockInfo">Block 1 / 24</span>
      <span class="pill" id="accInfo">Acc 0% (req 20%)</span>
      <span class="pill" id="autoInfo">Auto-next: Off</span>
      <span class="pill" id="delayInfo">RT limit: 1183ms ‚Ä¢ Delay: 1000ms</span>
      <span class="pill" id="timerInfo">Time left: 30:00</span>
      <span class="pill" id="chunkInfo">Training: 6:00 (1/6)</span>
      <span class="pill" id="jitterInfo" style="display:none;">Jitter: JL1</span>
      <span class="pill" id="octaveInfo" style="display:none;">Mix: 90/10</span>
    </div>
    <div id="barControls">
      <button id="btnPlay">‚ñ∂ Play</button>
      <button id="btnPause">‚è∏ Pause</button>
      <button id="btnToggleAuto">‚èØ Toggle Auto-next</button>
      <input id="delaySlider" type="range" min="0" max="2000" step="50" value="1000" style="width:220px">
      <button id="btnBackMenu">‚Ü© Menu</button>
    </div>

    <!-- Note pad -->
    <div class="note-pad" id="notePad"></div>
    <div class="note-pad" style="margin-top:6px">
      <button class="note wide" id="btnOOB" type="button">Out of Bounds</button>
    </div>

    <!-- Binary pad for specials -->
    <div class="note-pad" id="binaryPad" style="display:none">
      <button class="note" id="btnTarget" type="button">Target</button>
      <button class="note" id="btnOther" type="button">Other (OOB)</button>
    </div>

    <p style="opacity:.75;margin-top:8px">800 ms tone ‚Ä¢ RT limit adapts with set size ‚Ä¢ 24 blocks per set ‚Ä¢ Octaves 3‚Äì5 (C3‚ÄìC5) with performance mixing</p>
  </div>

  <!-- Assessment Screen -->
  <div id="assessmentScreen" class="screen">
    <div class="card">
      <h2>üìä Assessment Test</h2>
      <div class="row">
        <span class="pill" id="assessmentProgress">Trial 0 / 20</span>
        <button id="btnBackMenuAssessment">‚Ü© Menu</button>
      </div>
      
      <div style="text-align:center;margin:20px 0">
        <span id="assessmentPrompt" class="pill">Press Start to begin assessment</span>
        <div style="margin-top:12px">
          <button id="btnStartAssessment">‚ñ∂ Start Assessment</button>
        </div>
      </div>
      
      <!-- Note pad for assessment -->
      <div class="note-pad" id="assessmentPad"></div>
      
      <div id="assessmentResults" style="display:none;text-align:center;margin-top:20px">
        <h3>Assessment Results</h3>
        <div id="assessmentStats" style="margin:16px 0"></div>
        <button id="btnRetryAssessment">Try Again</button>
        <button id="btnBackMenuFromResults">Back to Menu</button>
      </div>
      
      <p style="opacity:.75;margin-top:8px">20 random pitches using random audio types ‚Ä¢ No feedback during test</p>
    </div>
  </div>

  <!-- Feedback -->
  <div id="feedbackOverlay"><div id="feedbackBox"></div></div>



  <!-- Flappy -->
  <div id="flappyModal">
    <div class="card" style="text-align:center">
      <h3>üê§ Flappy Break</h3>
      <p id="breakCountdown" style="display:none;font-size:16px;font-weight:bold;margin:8px 0;color:var(--accent);">Break ends in: 60s</p>
      <canvas id="flappyCanvas" width="320" height="480"></canvas>
      <div style="margin-top:8px">
        <button id="flappySoundToggle" style="display:none;margin-right:8px">üîä Sound On</button>
        <button id="flappyClose">Close</button>
      </div>
      <p id="flappyScore">Score: 0 ‚Ä¢ Best: 0</p>
      <p style="opacity:.8;font-size:12px">Tap/click (or Space) to flap. First tap starts ‚Äî each flap plays a random pitch.</p>
    </div>
  </div>

  <!-- Assessment Warning Modal -->
  <div id="assessmentWarningModal" style="position:fixed;inset:0;background:rgba(0,0,0,.7);display:none;align-items:center;justify-content:center;z-index:70">
    <div class="card" style="max-width:500px;margin:20px;text-align:center">
      <h2>üìä Assessment Test</h2>
      <p><strong>Timing Recommendations:</strong></p>
      <ul style="text-align:left;margin:16px 0">
        <li>Take this test at the <strong>start of your 8-week training program</strong></li>
        <li>Take it again at the <strong>end of the 8 weeks</strong> to track improvement</li>
        <li>Optionally take it <strong>weekly</strong> to monitor progress</li>
      </ul>
      <p style="opacity:0.8">This test uses 20 random pitches across different audio types without feedback to assess your current absolute pitch ability.</p>
      <div style="margin-top:20px">
        <button id="btnProceedAssessment" style="background:var(--good);margin:0 8px">Continue to Test</button>
        <button id="btnCancelAssessment" style="background:var(--muted);margin:0 8px">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Assessment Results Modal -->
  <div id="assessmentResultsModal" style="position:fixed;inset:0;background:rgba(0,0,0,.7);display:none;align-items:center;justify-content:center;z-index:70">
    <div class="card" style="max-width:500px;margin:20px;text-align:center">
      <h2>üìä Assessment Complete!</h2>
      <div id="modalAssessmentStats" style="margin:20px 0;font-size:18px"></div>
      <p style="opacity:0.8;margin:16px 0">Your results have been saved to the tracker.</p>
      <div style="margin-top:20px">
        <button id="btnRetakeAssessmentModal" style="background:var(--good);margin:0 8px">Try Again</button>
        <button id="btnBackMenuModal" style="background:var(--muted);margin:0 8px">Back to Menu</button>
      </div>
    </div>
  </div>

  <!-- Strict session modal -->
  <div id="strictModal" aria-modal="true" role="dialog">
    <div id="strictBox" class="card">
      <h3>‚ö†Ô∏è Don‚Äôt break your session</h3>
      <p>Training is meant to be one strict 30-minute session without interruption. Please finish, then wait until tomorrow.</p>
      <div id="strictBtns">
        <button id="btnStrictResume">Resume Training</button>
        <button id="btnStrictMenu">Go to Menu</button>
      </div>
    </div>
  </div>

  <!-- New Pitch Introduction Modal -->
  <div id="newPitchModal" aria-modal="true" role="dialog">
    <div id="newPitchBox" class="card">
      <h2>üéâ Well Done!</h2>
      <p id="newPitchMessage">Now you are learning: <strong id="newPitchName">F</strong></p>
      <div id="newPitchBtns">
        <button id="btnHearNewPitch">üîä Hear It</button>
        <button id="btnContinueTraining">Continue</button>
      </div>
    </div>
  </div>

  <!-- Pitch Recall Modal -->
  <div id="recallModal" aria-modal="true" role="dialog" style="position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:1000;background:rgba(0,0,0,.55);pointer-events:auto">
    <div id="recallBox" style="width:min(600px,92vw);background:var(--card);border:1px solid var(--muted);border-radius:16px;padding:18px 20px;box-shadow:0 20px 60px rgba(0,0,0,.5)">
      <h2 id="recallTitle">üéµ Cold Recall Test</h2>
      <p id="recallInstruction">Before training, please sing/hum the following notes to test your pitch memory:</p>
      
      <div id="recallProgress" style="margin:16px 0">
        <span class="pill" id="recallCounter">Note 1 of 3</span>
        <span class="pill" id="recallCurrentNote">F</span>
      </div>
      
      <div style="text-align:center;margin:20px 0">
        <div id="recallPrompt" style="font-size:18px;margin:12px 0">
          <span>Sing or hum: <strong id="recallTargetNote">F</strong></span>
        </div>
        
        <div style="margin:16px 0">
          <button id="btnStartRecording" style="background:var(--good);font-size:16px;padding:12px 20px">üé§ Start Recording (2s)</button>
          <button id="btnStopRecording" style="background:var(--bad);font-size:16px;padding:12px 20px;display:none">‚èπ Stop Recording</button>
        </div>
        
        <div id="recallFeedback" style="margin:16px 0;min-height:60px;display:none">
          <div id="recallResults" style="font-size:16px;margin:8px 0"></div>
          <div id="recallVerdict" style="font-size:14px;opacity:0.8"></div>
        </div>
      </div>
      
      <div id="recallButtons" style="display:flex;gap:10px;justify-content:flex-end;margin-top:12px">
        <button id="btnSkipRecall" style="background:var(--muted)">Skip This Test</button>
        <button id="btnNextRecall" style="background:var(--good);display:none">Next Note</button>
        <button id="btnFinishRecall" style="background:var(--good);display:none">Start Training</button>
      </div>
    </div>
  </div>

  <div id="bootError"></div>

<script>
/* ------------------ CONSTANTS ------------------ */
const AUDIO_PIANO='./audio';
const AUDIO_GUITAR='./Guitar';
const AUDIO_TYPES = {PIANO: 'piano', SINE: 'sine', GUITAR: 'guitar'};

// Theme definitions
const THEMES = {
  default: {
    name: 'Dark Ocean',
    bg: '#0f172a',
    card: '#1e293b', 
    muted: '#334155',
    muted2: '#2a3a54',
    text: '#e5e7eb',
    good: '#16a34a',
    bad: '#dc2626',
    accent: '#fbbf24',
    neutral: '#94a3b8'
  },
  beach: {
    name: 'Beach Sunset',
    bg: '#0f2027',
    card: '#2c5aa0',
    muted: '#44749d',
    muted2: '#5a86ba',
    text: '#fff8dc',
    good: '#ff7f50',
    bad: '#dc143c',
    accent: '#ffa500',
    neutral: '#87ceeb'
  },
  jungle: {
    name: 'Jungle Canopy', 
    bg: '#1a2f1a',
    card: '#2d4a2d',
    muted: '#456545',
    muted2: '#3a5a3a',
    text: '#e8f5e8',
    good: '#32cd32',
    bad: '#cd5c5c',
    accent: '#adff2f',
    neutral: '#9acd32'
  },
  sky: {
    name: 'Cloud Nine',
    bg: '#e6f2ff',
    card: '#ffffff',
    muted: '#b8d4f0',
    muted2: '#a3c9ea',
    text: '#1e3a8a',
    good: '#10b981',
    bad: '#ef4444',
    accent: '#3b82f6',
    neutral: '#6b7280'
  },
  desert: {
    name: 'Desert Oasis',
    bg: '#2d1810',
    card: '#8b4513',
    muted: '#cd853f',
    muted2: '#a0522d',
    text: '#faebd7',
    good: '#daa520',
    bad: '#b22222',
    accent: '#ff8c00',
    neutral: '#d2b48c'
  },
  neon: {
    name: 'Neon Nights',
    bg: '#0a0a0f',
    card: '#1a1a2e',
    muted: '#16213e',
    muted2: '#0f172a',
    text: '#00ffff',
    good: '#00ff00',
    bad: '#ff1493',
    accent: '#ff00ff',
    neutral: '#9370db'
  },
  forest: {
    name: 'Mystic Forest',
    bg: '#0d1421',
    card: '#1e3a3a',
    muted: '#2f5a5a',
    muted2: '#1a3030',
    text: '#f0fff0',
    good: '#228b22',
    bad: '#dc143c',
    accent: '#ffd700',
    neutral: '#8fbc8f'
  }
};
const PC=["C","Db","D","Eb","E","F","Gb","G","Ab","A","Bb","B"];
const PC_LABEL={ C:"C", Db:"C#/Db", D:"D", Eb:"D#/Eb", E:"E", F:"F", Gb:"F#/Gb", G:"G", Ab:"G#/Ab", A:"A", Bb:"A#/Bb", B:"B" };
const UNLOCK_ORDER = ["F","E","Gb","Eb","G","D","Ab","Db","A","C","Bb","B"];

const LEVELS_PER_SET=24, SETS=12, LEVELS_TOTAL=SETS*LEVELS_PER_SET;
const TONE_MS=800;
const THRESH_24=[0.20,0.25,0.30,0.35,0.40,0.45,0.50,0.55,0.60,0.60,0.65,0.70,0.75,0.78,0.80,0.83,0.85,0.88,0.90,0.90,0.90,0.90,0.90,0.90];
function blockHasFeedback(block){ return block<=20; }
function rtWindowForSet(n){const a=1183,b=2028;return Math.round(a+(n-1)*(b-a)/11);}

/* ------------------ JITTER LADDER SYSTEM ------------------ */
// B) BOUNDARY PROBE RATE - Jitter level configurations (JL0 = easiest, JL3 = hardest)
const JITTER_LEVELS = {
  0: { // JL0 - onboarding/new timbre  
    jitterRange: [3, 8],    // ¬±3-8¬¢
    anchorRate: 0.25,       // 25% anchors 
    probeRate: 0.12,        // 12% probes to achieve global ~10-12%
    name: 'JL0'
  },
  1: { // JL1 - early
    jitterRange: [5, 10],   // ¬±5-10¬¢
    anchorRate: 0.175,      // 15-20% anchors
    probeRate: 0.11,        // 11% probes
    name: 'JL1'
  },
  2: { // JL2 - mid
    jitterRange: [5, 15],   // ¬±5-15¬¢
    anchorRate: 0.125,      // 10-15% anchors
    probeRate: 0.10,        // 10% probes
    name: 'JL2'
  },
  3: { // JL3 - hardest
    jitterRange: [5, 15],   // ¬±5-15¬¢
    anchorRate: 0.075,      // 5-10% anchors
    probeRate: 0.12,        // 12% probes
    name: 'JL3'
  }
};

// C) JITTER LADDER LOGGING - Promotion/demotion thresholds
const JITTER_PROMOTION_RULES = {
  '0to1': { accuracy: 0.75, medianCents: 20 },   // JL0‚ÜíJL1 when acc ‚â• .75 AND median ‚â§ 20¬¢
  '1to2': { accuracy: 0.80, medianCents: 15 },   // JL1‚ÜíJL2 when acc ‚â• .80 AND median ‚â§ 15¬¢
  '2to3': { accuracy: 0.90, medianCents: 10, sdCents: 15 }  // JL2‚ÜíJL3 when acc ‚â• .90 AND median ‚â§ 10¬¢ AND SD ‚â§ 15¬¢
};

const JITTER_DEMOTION_RULES = {
  accuracy: 0.75,    // Drop 1 level if acc < 75%
  medianCents: 25,   // Drop 1 level if median > 25¬¢
  sdCents: 30        // Drop 1 level if SD > 30¬¢
};
/* ------------------ ENHANCED OOB SYSTEM ------------------ */
// B) OOB GENERATION = BERNOULLI PER TRIAL + ‚â§2 STREAK with 3-block cadence adaptation
function shouldGenerateOOB(set) {
  const oobs = currentOOBs(set);
  if (oobs.length === 0) return false;
  
  const rate = getAdaptiveOOBTarget();
  const canOOB = (state.oobStats.streakCount || 0) < (state.oobStats.maxInRow || 2);
  
  const isOOB = canOOB && Math.random() < rate;
  state.oobStats.streakCount = isOOB ? (state.oobStats.streakCount + 1) : 0;
  return isOOB;
}

// Get current OOB target rate (adaptation happens at block boundaries only)
function getAdaptiveOOBTarget() {
  // Initialize adaptation tracking if needed
  if (!state.oobStats.adaptationCount) {
    state.oobStats.adaptationCount = 0;
  }
  
  return state.oobStats.adaptiveRate ?? 0.18;
}

// Check if adaptation should run at block end - only every 3 blocks
function shouldAdaptAtBlockEnd(block) {
  // Only adapt every 3 blocks (3, 6, 9, 12, ...)
  if (block % 3 !== 0) return false;
  
  // Guard: Don't adapt the same block multiple times
  if (state.oobStats.lastAdaptedBlock === block) return false;
  
  // In simulation mode, limit total adaptations to prevent spam
  const maxAdaptations = typeof window.runSimWeek !== 'undefined' ? 7 : Infinity;
  if (state.oobStats.adaptationCount >= maxAdaptations) return false;
  
  return true;
}

// Adapt OOB target every 3 blocks based on last 60 in-bounds trials
function adaptOOBTarget() {
  // Get last 60 graded in-bounds trials
  const last60InBounds = state.trials
    .filter(t => !t.oob && t.correct !== undefined)
    .slice(-60);
  
  if (last60InBounds.length < 30) {
    // Not enough data, keep current rate
    return;
  }
  
  const observedAcc = last60InBounds.filter(t => t.correct).length / last60InBounds.length;
  const last60Acc = num(observedAcc, 0); // Store as fraction 0..1, safely normalized
  
  let newTarget = state.oobStats.adaptiveRate ?? 0.18;
  let reason = 'no-change';
  
  // Target policy: nudge toward 70-85% overall accuracy using ¬±3pp steps
  if (observedAcc < 0.70) {
    newTarget = Math.max(0.05, newTarget - 0.03); // Decrease OOB rate to make easier
    reason = 'accuracy-too-low';
  } else if (observedAcc > 0.85) {
    newTarget = Math.min(0.35, newTarget + 0.03); // Increase OOB rate to make harder
    reason = 'accuracy-too-high';
  }
  
  // Clamp to 5-35% range
  newTarget = Math.max(0.05, Math.min(0.35, newTarget));
  
  // Calculate observed OOB percentage in current time block (for observedPctThisBlock)
  const currentBlockTrials = state.trials.filter(t => {
    // Approximate current block trials (this could be refined with better time tracking)
    return t.time && t.time > (Date.now() - BLOCK_LEN_MIN * 60 * 1000);
  });
  const currentBlockOOB = currentBlockTrials.filter(t => t.oob);
  const observedPctThisBlock = currentBlockTrials.length > 0 ? 
    num(currentBlockOOB.length / currentBlockTrials.length, 0) : 0;
  
  // Record the adaptation in oobSeries per problem statement format
  if (!state.oobSeries) state.oobSeries = [];
  if (!state.qa.oob.series) state.qa.oob.series = [];
  
  const oobRecord = {
    globalTimeBlockIndex: state.counters.globalTimeBlockIndex,
    targetPct: num(newTarget, 0.18), // Store as fraction 0..1, safely normalized
    last60Acc: last60Acc, // Store as fraction 0..1
    observedPctThisBlock: observedPctThisBlock // Fraction 0..1
  };
  
  state.oobSeries.push(oobRecord);
  state.qa.oob.series.push(oobRecord);
  
  // Freeze the new target for the next Time-Block
  state.oobStats.adaptiveRate = newTarget;
  state.oobStats.adaptationCount = (state.oobStats.adaptationCount || 0) + 1;
  
  // Add debug logging
  const currentBlock = blockFromIndex(state.levelIndex);
  console.log(`OOB_ADAPT globalTimeBlock=${state.counters.globalTimeBlockIndex} last60_acc=${Math.round(last60Acc*100)}% new_target=${Math.round(newTarget * 100)}%`);
  
  save();
}

function recordOOBTrial(wasOOB, correct) {
  const stats = state.oobStats;
  
  if (wasOOB) {
    // Add to OOB trials tracking
    stats.oobTrials.push({ correct, timestamp: Date.now() });
    if (stats.oobTrials.length > 20) {
      stats.oobTrials = stats.oobTrials.slice(-20);
    }
    
    // D) OOB HEALTH CHECK (novice case)
    if (stats.oobTrials.length >= 20) {
      const oobAccuracy = stats.oobTrials.filter(t => t.correct).length / stats.oobTrials.length;
      if (oobAccuracy < 0.60) {
        // For the next 2 blocks set reduced rate
        stats.healthCheckActive = true;
        stats.healthCheckBlocks = 2;
      } else if (oobAccuracy >= 0.75 && stats.healthCheckActive) {
        // Restore when OOB ‚â• 0.75
        stats.healthCheckActive = false;
        stats.healthCheckBlocks = 0;
      }
    }
  } else {
    // Add to recent in-bounds trials for adaptation
    stats.recentTrials.push({ correct, timestamp: Date.now() });
    if (stats.recentTrials.length > 60) {
      stats.recentTrials = stats.recentTrials.slice(-60);
    }
  }
  
  save();
}

// Enhanced OOB selection with octave mirroring
function selectOOBNote(set) {
  const oobs = currentOOBs(set);
  if (oobs.length === 0) return null;
  
  // Prefer OOB chroma far from trained notes if health check is active
  if (state.oobStats?.healthCheckActive) {
    const trainedPcs = trainedSet(set);
    const farOOBs = oobs.filter(oob => {
      return !trainedPcs.some(trained => {
        const oobIdx = PC.indexOf(oob);
        const trainedIdx = PC.indexOf(trained);
        const dist = Math.min(
          Math.abs(oobIdx - trainedIdx),
          12 - Math.abs(oobIdx - trainedIdx)
        );
        return dist <= 1; // Avoid ¬±1 semitone
      });
    });
    
    if (farOOBs.length > 0) {
      return rand(farOOBs);
    }
  }
  
  return rand(oobs);
}

/* ------------------ JITTER LEVEL MANAGEMENT ------------------ */
// Initialize jitter level for a note if not already set
function initializeJitterLevel(pc) {
  if (!state.jitterLevels) state.jitterLevels = {};
  if (!state.jitterRangeUsed) state.jitterRangeUsed = {};
  if (!state.promotionEvents) state.promotionEvents = {};
  if (!state.demotionEvents) state.demotionEvents = {};
  
  if (!(pc in state.jitterLevels)) {
    state.jitterLevels[pc] = 0; // Start at JL0
    save();
  }
  
  // Update current range being used
  const level = state.jitterLevels[pc];
  const config = JITTER_LEVELS[level];
  state.jitterRangeUsed[pc] = `¬±${config.jitterRange[0]}-${config.jitterRange[1]}¬¢`;
  
  // Initialize event tracking if needed
  if (!(pc in state.promotionEvents)) state.promotionEvents[pc] = [];
  if (!(pc in state.demotionEvents)) state.demotionEvents[pc] = [];
}

// Initialize note statistics for tracking
function initializeNoteStats(pc) {
  if (!state.noteStats) state.noteStats = {};
  if (!(pc in state.noteStats)) {
    state.noteStats[pc] = {
      trials: [],           // Last ~40 trials
      accuracy: 0,
      medianError: 0,
      sdError: 0,
      meanAbsCents: 0
    };
    save();
  }
}

// Update note statistics after a trial
function updateNoteStats(pc, correct, jitterCents) {
  initializeNoteStats(pc);
  const stats = state.noteStats[pc];
  
  // Add new trial (keep last 40)
  stats.trials.push({
    correct: correct,
    jitterCents: Math.abs(jitterCents || 0),
    timestamp: Date.now()
  });
  
  if (stats.trials.length > 40) {
    stats.trials = stats.trials.slice(-40);
  }
  
  // Recalculate statistics
  if (stats.trials.length > 0) {
    stats.accuracy = stats.trials.filter(t => t.correct).length / stats.trials.length;
    
    const errors = stats.trials.map(t => t.jitterCents);
    errors.sort((a, b) => a - b);
    stats.medianError = errors[Math.floor(errors.length / 2)] || 0;
    
    const mean = errors.reduce((a, b) => a + b, 0) / errors.length;
    const variance = errors.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / errors.length;
    stats.sdError = Math.sqrt(variance);
    stats.meanAbsCents = mean;
  }
  
  save();
}

// C) JITTER LADDER LOGGING - Check for jitter level promotion
function checkJitterPromotion(pc) {
  initializeJitterLevel(pc);
  initializeNoteStats(pc);
  
  const currentLevel = state.jitterLevels[pc];
  const stats = state.noteStats[pc];
  
  if (stats.trials.length < 20) return; // Need enough data
  
  // Check promotion rules
  let canPromote = false;
  let newLevel = currentLevel;
  
  if (currentLevel === 0) {
    // JL0 ‚Üí JL1 when acc ‚â• .75 AND median ‚â§ 20¬¢
    const rule = JITTER_PROMOTION_RULES['0to1'];
    if (stats.accuracy >= rule.accuracy && stats.medianError <= rule.medianCents) {
      canPromote = true;
      newLevel = 1;
    }
  } else if (currentLevel === 1) {
    // JL1 ‚Üí JL2 when acc ‚â• .80 AND median ‚â§ 15¬¢
    const rule = JITTER_PROMOTION_RULES['1to2'];
    if (stats.accuracy >= rule.accuracy && stats.medianError <= rule.medianCents) {
      canPromote = true;
      newLevel = 2;
    }
  } else if (currentLevel === 2) {
    // JL2 ‚Üí JL3 when acc ‚â• .90 AND median ‚â§ 10¬¢ AND SD ‚â§ 15¬¢
    const rule = JITTER_PROMOTION_RULES['2to3'];
    if (stats.accuracy >= rule.accuracy && 
        stats.medianError <= rule.medianCents && 
        stats.sdError <= rule.sdCents) {
      canPromote = true;
      newLevel = 3;
    }
  }
  
  if (canPromote) {
    state.jitterLevels[pc] = newLevel;
    
    // Record promotion event in problem statement format 
    const event = {
      globalTimeBlockIndex: state.counters.globalTimeBlockIndex,
      pc: pc,
      from: currentLevel,
      to: newLevel,
      acc: num(stats.accuracy, null),
      medianCents: num(stats.medianError, null),
      sdCents: num(stats.sdError, null),
      windowN: stats.trials.length
    };
    
    // Update both legacy and qa structures
    state.jitter.levelEvents.push(event);
    state.qa.jitter.levelEvents.push(event);
    state.qa.jitter.levels[pc] = newLevel;
    
    // Update jitter range used
    const config = JITTER_LEVELS[newLevel];
    state.jitterRangeUsed[pc] = `¬±${config.jitterRange[0]}-${config.jitterRange[1]}¬¢`;
    
    save();
  }
}

// Check for jitter level demotion
function checkJitterDemotion(pc) {
  initializeJitterLevel(pc);
  initializeNoteStats(pc);
  
  const currentLevel = state.jitterLevels[pc];
  const stats = state.noteStats[pc];
  
  if (currentLevel === 0 || stats.trials.length < 15) return; // Can't demote from JL0, need data
  
  // Use last ~20 trials for demotion check
  const recentTrials = stats.trials.slice(-20);
  if (recentTrials.length < 15) return;
  
  const recentAcc = recentTrials.filter(t => t.correct).length / recentTrials.length;
  const recentErrors = recentTrials.map(t => Math.abs(t.cents || 0));
  recentErrors.sort((a, b) => a - b);
  const recentMedian = recentErrors[Math.floor(recentErrors.length / 2)] || 0;
  const recentMean = recentErrors.reduce((a, b) => a + b, 0) / recentErrors.length;
  const recentVariance = recentErrors.reduce((a, b) => a + Math.pow(b - recentMean, 2), 0) / recentErrors.length;
  const recentSD = Math.sqrt(recentVariance);
  
  const rules = JITTER_DEMOTION_RULES;
  // Demote one level if acc < .75 OR median > 25¬¢ OR SD > 30¬¢ (over last ~20)
  const shouldDemote = recentAcc < rules.accuracy || 
                       recentMedian > rules.medianCents || 
                       recentSD > rules.sdCents;
  
  if (shouldDemote) {
    const newLevel = Math.max(0, currentLevel - 1);
    state.jitterLevels[pc] = newLevel;
    
    // Record demotion event in problem statement format
    const event = {
      globalTimeBlockIndex: state.counters.globalTimeBlockIndex,
      pc: pc,
      from: currentLevel,
      to: newLevel,
      acc: num(recentAcc, null),
      medianCents: num(recentMedian, null),
      sdCents: num(recentSD, null),
      windowN: recentTrials.length
    };
    
    // Update both legacy and qa structures
    state.jitter.levelEvents.push(event);
    state.qa.jitter.levelEvents.push(event);
    state.qa.jitter.levels[pc] = newLevel;
    
    // Update jitter range used
    const config = JITTER_LEVELS[newLevel];
    state.jitterRangeUsed[pc] = `¬±${config.jitterRange[0]}-${config.jitterRange[1]}¬¢`;
    
    save();
  }
}

// B) BOUNDARY PROBE RATE - Check if note needs rescue mode (poor performance)
function needsRescueMode(pc) {
  initializeNoteStats(pc);
  const stats = state.noteStats[pc];
  
  if (!stats || stats.trials.length < 10) return false; // Need some data
  
  // Check rolling accuracy and median error for last 40 trials
  const recentTrials = stats.trials.slice(-40);
  if (recentTrials.length < 20) return false; // Need at least 20 trials
  
  const recentCorrect = recentTrials.filter(t => t.correct).length;
  const recentAcc = recentCorrect / recentTrials.length;
  
  // Calculate median and SD of absolute error
  const recentErrors = recentTrials.map(t => Math.abs(t.cents || 0));
  recentErrors.sort((a, b) => a - b);
  const medianError = recentErrors[Math.floor(recentErrors.length / 2)];
  
  const meanError = recentErrors.reduce((sum, e) => sum + e, 0) / recentErrors.length;
  const variance = recentErrors.reduce((sum, e) => sum + Math.pow(e - meanError, 2), 0) / recentErrors.length;
  const sdError = Math.sqrt(variance);
  
  // "Rescue" rule: if rolling last-40 acc < 0.75 OR median abs cents > 25¬¢ OR SD > 30¬¢
  return recentAcc < 0.75 || medianError > 25 || sdError > 30;
}

// Get rescue mode config for a note
function getRescueConfig(pc) {
  if (!needsRescueMode(pc)) return null;
  
  // Temporarily drop one JL level and clamp probes to ‚â§4%
  const currentLevel = state.jitterLevels[pc] || 0;
  const rescueLevel = Math.max(0, currentLevel - 1);
  const rescueConfig = JITTER_LEVELS[rescueLevel];
  
  return {
    jitterRange: rescueConfig.jitterRange,
    probeRate: Math.min(0.04, rescueConfig.probeRate), // Clamp probes to ‚â§4%
    anchorRate: rescueConfig.anchorRate,
    isRescue: true,
    originalLevel: currentLevel,
    rescueLevel: rescueLevel
  };
}

// Generate jitter for a note based on its level
function generateJitterForNote(pc, isProbe = false) {
  initializeJitterLevel(pc);
  
  // Check for rescue mode first
  const rescueConfig = getRescueConfig(pc);
  const config = rescueConfig || JITTER_LEVELS[state.jitterLevels[pc]];
  
  if (isProbe) {
    // Probe: ¬±25-40¬¢ range (outside normal jitter range)
    const sign = Math.random() < 0.5 ? -1 : 1;
    return sign * (25 + Math.random() * 15); // 25-40 cents
  } else {
    // Regular jitter based on level (or rescue mode)
    const [min, max] = config.jitterRange;
    const sign = Math.random() < 0.5 ? -1 : 1;
    return sign * (min + Math.random() * (max - min));
  }
}

// Check if should use probe for this note
function shouldUseProbe(pc) {
  initializeJitterLevel(pc);
  
  // Check for rescue mode first
  const rescueConfig = getRescueConfig(pc);
  if (rescueConfig) {
    return Math.random() < rescueConfig.probeRate;
  }
  
  const level = state.jitterLevels[pc];
  const config = JITTER_LEVELS[level];
  return Math.random() < config.probeRate;
}

// Check if should use anchor (0¬¢) for this note
function shouldUseAnchor(pc) {
  initializeJitterLevel(pc);
  
  // Check for rescue mode first
  const rescueConfig = getRescueConfig(pc);
  if (rescueConfig) {
    return Math.random() < rescueConfig.anchorRate;
  }
  
  const level = state.jitterLevels[pc];
  const config = JITTER_LEVELS[level];
  return Math.random() < config.anchorRate;
}

// Get jitter info for a trial
function getJitterInfo(pc) {
  initializeJitterLevel(pc);
  
  const level = state.jitterLevels[pc] || 0;
  const isAnchor = shouldUseAnchor(pc);
  
  if (isAnchor) {
    return {
      cents: 0,
      mode: "anchor",
      level: level
    };
  }
  
  const isProbe = shouldUseProbe(pc);
  const jitter = generateJitterForNote(pc, isProbe);
  
  return {
    cents: num(jitter, null),
    mode: isProbe ? "probe" : "jitter",
    level: level
  };
}

// Debug function to show jitter status table
window.jitterStatus = function() {
  console.log('=== JITTER STATUS ===');
  console.log('PC\tJL\tJitter Range\tAnchors%\tProbes%\tLast-40 Acc\tMedian¬¢\tSD¬¢');
  
  PC.forEach(pc => {
    initializeJitterLevel(pc);
    initializeNoteStats(pc);
    
    const level = state.jitterLevels[pc];
    const config = JITTER_LEVELS[level];
    const stats = state.noteStats[pc];
    
    const jitterRange = `¬±${config.jitterRange[0]}-${config.jitterRange[1]}¬¢`;
    const anchorsPercent = fmtPct(config.anchorRate, 1);
    const probesPercent = fmtPct(config.probeRate, 1);
    const accuracy = stats.trials.length > 0 ? fmtPct(stats.accuracy, 0) : 'N/A';
    const medianCents = stats.trials.length > 0 ? fmtN(stats.medianError, 0) + '¬¢' : 'N/A';
    const sdCents = stats.trials.length > 0 ? fmtN(stats.sdError, 0) + '¬¢' : 'N/A';
    
    console.log(`${pc}\t${config.name}\t${jitterRange}\t\t${anchorsPercent}\t\t${probesPercent}\t\t${accuracy}\t\t${medianCents}\t${sdCents}`);
  });
};

const OOB_RATE=0.25; // Keep as fallback, but use adaptive rate
const SESS_DAILY_MS=30*60*1000; // Changed from 20 to 30 minutes
const WEEKLY_TARGET_MS=2*3600*1000;
const BLOCK_LEN_MIN = 6; // Length of each training block in minutes
const BREAK_SEC = 60; // Length of mandatory break in seconds
const BREAK_INTERVAL_MS=BLOCK_LEN_MIN*60*1000; // Break every 6 minutes
const BREAK_DURATION_MS=BREAK_SEC*1000; // 60-second mandatory break
// Lockout until next calendar day (calculated dynamically)
const RECALL_DURATION_MS=2000; // 2-second recording for recall tests
const RECALL_SAMPLE_RATE=22050; // Lower sample rate for recall processing
const LATENCY_CUSHION_MS=100;
const DEV_UI = false; // Controls debug UI visibility

/* ------------------ THEME SYSTEM ------------------ */
function applyTheme(themeName) {
  const theme = THEMES[themeName] || THEMES.default;
  const root = document.documentElement;
  
  root.style.setProperty('--bg', theme.bg);
  root.style.setProperty('--card', theme.card);
  root.style.setProperty('--muted', theme.muted);
  root.style.setProperty('--muted2', theme.muted2);
  root.style.setProperty('--text', theme.text);
  root.style.setProperty('--good', theme.good);
  root.style.setProperty('--bad', theme.bad);
  root.style.setProperty('--accent', theme.accent);
  root.style.setProperty('--neutral', theme.neutral);
}

/* ------------------ SAFE HELPERS + STATE ------------------ */
function byId(id){ return document.getElementById(id); }
function safe(id, fn){ const el=byId(id); if(el) try{ fn(el); }catch(e){report(e);} }
function showFlex(id){ safe(id, el=> el.style.display='flex'); }
function showBlock(id){ safe(id, el=> el.style.display='block'); }
function hide(id){ safe(id, el=> el.style.display='none'); }
function text(id, v){ safe(id, el=> el.textContent=v); }
function textWithTooltip(id, v){ 
  safe(id, el=> {
    const tooltip = el.querySelector('.tooltip-content');
    el.textContent = v;
    if (tooltip) {
      el.appendChild(tooltip);
    }
  }); 
}

// Initialize tooltips for UI pills
function initializeTooltips() {
  const tooltips = {
    setInfo: "Shows how many pitches you're currently learning. You start with 1 pitch (F) and gradually add more up to all 12 pitches.",
    blockInfo: "Each set has 24 blocks. Blocks 1-20 give feedback, blocks 21-24 are tests with no feedback. You need to achieve the required accuracy to advance.",
    accInfo: "Your current accuracy percentage and the required accuracy to advance to the next block. The requirement increases with each block.",
    autoInfo: "When enabled, the next tone plays automatically after the delay period. Toggle with the ‚èØ button or adjust the delay slider.",
    delayInfo: "RT limit: Maximum reaction time to answer before timeout. Delay: Time between trials when auto-next is enabled.",
    timerInfo: "Remaining time in your 30-minute daily training session. Timer only runs during active training, not during menus or breaks.",
    chunkInfo: "Time remaining in current 6-minute training chunk before a mandatory 60-second break. Shows current chunk number out of 5 total chunks.",
    jitterInfo: "Jitter Level shows how much pitch variation is added for training. JL0 = easiest (¬±3-8¬¢), JL1 = early (¬±5-10¬¢), JL2 = mid (¬±5-15¬¢), JL3 = hardest (¬±5-15¬¢ + probes). Example: currently you are on JL0 for F, JL2 for E. Jitter helps you learn where the pitch boundaries are.",
    octaveInfo: "Octave mixing ratio. Shows percentage of center octave vs neighbor octaves. Adaptive mixing based on your performance to encourage learning pitch class rather than absolute pitch height."
  };
  
  Object.keys(tooltips).forEach(id => {
    const element = byId(id);
    if (element) {
      element.classList.add('clickable', 'tooltip');
      let tooltipContent = element.querySelector('.tooltip-content');
      if (!tooltipContent) {
        tooltipContent = document.createElement('div');
        tooltipContent.className = 'tooltip-content';
        tooltipContent.textContent = tooltips[id];
        element.appendChild(tooltipContent);
      }
    }
  });
}
function report(err){ const el=byId('bootError'); if(!el) return; el.style.display='block'; el.textContent = '‚ö†Ô∏è Script error: ' + (err && err.message ? err.message : String(err)); if(err && err.stack){ el.textContent += '\n' + err.stack; } }

let state;
try{
  state = JSON.parse(localStorage.getItem('apTrainer')||'null') || {
    userName:null,
    levelIndex:1,
    levelTrials:0, levelCorrect:0,
    sessions:[], trials:[], tones:[],
    startDate:null, lockoutUntil:null, capResetAt:null,
    testFailStreak:0, suggestShownSet:null,
    lastSeen:null, flappyHighScore:0,
    thisWeekIdx:0, thisWeekMs:0,
    levelFailCounts:{},
    specialRanForLevel:null,
    audioType: AUDIO_TYPES.PIANO,
    assessmentScores: [],
    theme: 'default',
    flappySoundEnabled: true,
    awaitingInput: false, // Track when input should be accepted
    // New state for enhanced features
    sessionBreakTime: 0, // Time when next break should occur
    lastBreakTime: 0, // Time of last break
    inBreak: false, // Currently in a break
    coldRecallDone: false, // Cold recall completed today
    warmRecallDone: false, // Warm recall completed today
    recallResults: [], // Recall test results
    jitterLevels: {}, // Per-note jitter levels (JL0-JL3)
    jitterRangeUsed: {}, // Per-note current jitter range being used
    promotionEvents: {}, // Per-note promotion history
    demotionEvents: {}, // Per-note demotion history
    confusionMatrix: {}, // 12x12 confusion tracking
    noteStats: {}, // Per-note rolling statistics
    varietyModeEnabled: false, // Timbre variety mode
    minutesToday: 0, // Track minutes completed today in 6-minute blocks
    // Unified cadence tracking per glossary
    trialIndex: 0, // Total trials (all types)
    inbTrialIndex: 0, // In-bounds graded trials only
    qBlockIndex: 0, // Q-Block index (every 20 in-bounds trials)
    timeBlockIndex: 0, // Time-Block index within day (1..5)
    globalTimeBlockIndex: 0, // Global Time-Block index (monotonic across days)
    lastOOBAdaptAt: { inbTrialIndex: 0, globalTimeBlockIndex: 0 }, // Last OOB adaptation point
    oobSeries: [], // OOB adaptation series for export
    mirrorDiffPerBlock: [] // Per-block mirror difference in percentage points
  };
} catch(e){
  state = { userName:null, levelIndex:1, levelTrials:0, levelCorrect:0, sessions:[], trials:[], tones:[], startDate:null, lockoutUntil:null, capResetAt:null, testFailStreak:0, suggestShownSet:null, lastSeen:null, flappyHighScore:0, thisWeekIdx:0, thisWeekMs:0, levelFailCounts:{}, specialRanForLevel:null, audioType: AUDIO_TYPES.PIANO, awaitingInput: false };
}

// Initialize QA arrays for recording as specified in problem statement
window.qa = window.qa || {};
qa.tones = qa.tones || [];
qa.trials = qa.trials || [];
qa.oobSeries = qa.oobSeries || [];

// Migration for audioType
if (!state.audioType) {
  state.audioType = AUDIO_TYPES.PIANO;
  save();
}
// Migration for assessmentScores
if (!state.assessmentScores) {
  state.assessmentScores = [];
  save();
}
// Migration for theme
if (!state.theme) {
  state.theme = 'default';
  save();
}
// Migration for flappySoundEnabled
if (state.flappySoundEnabled === undefined) {
  state.flappySoundEnabled = true;
  save();
}
// Migration for new enhanced features
if (state.sessionBreakTime === undefined) {
  state.sessionBreakTime = 0;
  state.lastBreakTime = 0;
  state.inBreak = false;
  state.coldRecallDone = false;
  state.warmRecallDone = false;
  state.recallResults = [];
  state.jitterLevels = {};
  state.jitterRangeUsed = {};
  state.promotionEvents = {};
  state.demotionEvents = {};
  state.confusionMatrix = {};
  state.noteStats = {};
  state.varietyModeEnabled = false;
  state.octaveWindowMetrics = [];
  state.weightsTrace = [];
  save();
}
// Migration for awaitingInput state tracking
if (state.awaitingInput === undefined) {
  state.awaitingInput = false;
  save();
}

// Migration for tones array (FIX 1)
if (!state.tones) {
  state.tones = [];
  save();
}

// A) INITIALIZE/REPAIR STATE (prevents .push crash)
state.oobStats ??= {};
state.oobStats.oobTrials ??= [];
state.oobStats.recentTrials ??= [];   // in-bounds only, 1/0
state.oobStats.streakCount ??= 0;     // generation streak
if (typeof state.oobStats.adaptiveRate !== 'number') state.oobStats.adaptiveRate = 0.18; // 18%
state.oobStats.maxInRow = 2;          // streak cap
state.oobSeries ??= [];               // OOB adaptation log

// A) OOB OCTAVE MIRRORING - Initialize tracking
state.oobOctaveMirror ??= [];         // Block-by-block octave mirroring data

// C) JITTER LADDER LOGGING - Initialize enhanced jitter tracking  
state.jitterLevels ??= {};            // Per-pitch jitter levels (JL0-JL3) - numeric
state.jitter ??= {};
state.jitter.levelEvents ??= [];      // Promotion/demotion events
state.jitter.byPitch ??= {};          // Daily snapshots per pitch

// D) CURRICULUM/SCHEDULER LOGGING - Initialize tracking
state.curriculum ??= {};
state.curriculum.active ??= [];       // Active pitches array
state.curriculum.weights ??= {};      // Pitch weights (fractions)
state.curriculum.events ??= [];       // Scheduler events

// E) RECALL SUMMARIES - Initialize enhanced recall tracking
state.recall ??= {};                  // Per-day recall results

// F) UNIFIED CADENCE TRACKING - Initialize centralized counters as specified
state.counters ??= {
  trialIndex: state.trials?.length || 0,            // all trials (in-bounds + OOB)
  inbTrialIndex: state.trials?.filter(t => !t.oob && t.correct !== undefined).length || 0,         // in-bounds only
  timeBlockIndex: Math.min(5, Math.floor(((state.minutesToday || 0) % 30) / 6) + 1),        // 1..5 today
  globalTimeBlockIndex: Math.floor((state.minutesToday || 0) / 6),  // increases across days
  qBlockIndex: Math.floor((state.trials?.filter(t => !t.oob && t.correct !== undefined).length || 0) / 20) + 1,
  lastOOBAdaptAt: { globalTimeBlockIndex: 0, inbTrialIndex: 0 }
};

// Maintain backward compatibility
state.trialIndex ??= state.counters.trialIndex;
state.inbTrialIndex ??= state.counters.inbTrialIndex;
state.qBlockIndex ??= state.counters.qBlockIndex;
state.timeBlockIndex ??= state.counters.timeBlockIndex;
state.globalTimeBlockIndex ??= state.counters.globalTimeBlockIndex;
state.lastOOBAdaptAt ??= state.counters.lastOOBAdaptAt;

// Initialize octave tracking properly (preserve existing, ensure QA)
state.oobSeries ??= [];
if (!state.octaveStats || typeof state.octaveStats !== 'object') {
  state.octaveStats = { inBounds: {3:0, 4:0, 5:0}, oob: {3:0, 4:0, 5:0} };
} else {
  state.octaveStats.inBounds ??= {3:0, 4:0, 5:0};
  state.octaveStats.oob ??= {3:0, 4:0, 5:0};
}
state.mirrorDiffPerBlock ??= [];

// Initialize QA tracking structures as specified
state.qa ??= {};
state.qa.oob ??= {};
state.qa.oob.series ??= []; // Will store time block adaptation records

state.qa.octaves ??= {};
state.qa.octaves.inBounds ??= { 3: 0, 4: 0, 5: 0 };
state.qa.octaves.oob ??= { 3: 0, 4: 0, 5: 0 };
state.qa.octaves.mirror ??= []; // Will store per-block octave mirroring data
state.qa.octaves.mirrorCheck ??= [];
state.qa.octaves.lastInBoundsWindow ??= { 3: 0, 4: 0, 5: 0 };
state.qa.octaves.inBoundsWindowTrials ??= [];

state.qa.detune ??= {};
state.qa.detune.shares ??= { counts: { anchors: 0, probes: 0, jitter: 0, total: 0 }, pct: {} };
state.qa.detune.byPitch ??= {};

state.qa.jitter ??= {};
state.qa.jitter.levels ??= {}; // Current JL per pitch
state.qa.jitter.levelEvents ??= []; // Promotion/demotion events

state.qa.confusion ??= {};
state.qa.confusion.matrix ??= {};

state.qa.curriculum ??= {};
state.qa.curriculum.active ??= [];
state.qa.curriculum.weights ??= {};
state.qa.curriculum.events ??= [];

// Initialize octave snapshot for OOB generation
state.octaveSnapshotForOOB ??= { inBoundsMix: {3: 0, 4: 1, 5: 0}, available: ["3", "4", "5"] };

// Update curriculum tracking
updateCurriculumTracking();

save();

/* ------------------ CURRICULUM TRACKING ------------------ */
function updateCurriculumTracking() {
  // Update active pitch classes based on current level
  const currentSet = setFromIndex(state.levelIndex);
  const activePitches = trainedSet(currentSet);
  
  // Check if active pitches have changed
  const previousActive = state.qa.curriculum.active;
  if (JSON.stringify(activePitches) !== JSON.stringify(previousActive)) {
    // Active pitches changed - record event
    state.qa.curriculum.events.push({
      globalTimeBlockIndex: state.counters.globalTimeBlockIndex,
      type: "addPitch",
      details: { 
        previous: [...previousActive],
        current: [...activePitches],
        newPitch: activePitches.find(p => !previousActive.includes(p))
      }
    });
  }
  
  // Update active pitches
  state.qa.curriculum.active = [...activePitches];
  
  // Calculate equal weights for active pitches
  const numActive = activePitches.length;
  if (numActive > 0) {
    const equalWeight = 1.0 / numActive;
    state.qa.curriculum.weights = {};
    activePitches.forEach(pc => {
      state.qa.curriculum.weights[pc] = equalWeight;
    });
  }
}

// Global variables for trial tracking
let trialStartTime = 0; // Track trial start time for RT measurement

// Apply theme on load
applyTheme(state.theme);
function save(){ try{ localStorage.setItem('apTrainer', JSON.stringify(state)); }catch(e){ report(e); } }
window.state = state;

/* ------------------ TIME HELPERS ------------------ */
function fmtMMSS(ms){ const s=Math.max(0,Math.floor(ms/1000)); const m=Math.floor(s/60); const ss=String(s%60).padStart(2,'0'); return `${m}:${ss}`; }
function fmtHMM(ms){ const s=Math.max(0,Math.floor(ms/1000)); const h=Math.floor(s/3600); const m=Math.floor((s%3600)/60); return `${h}h ${String(m).padStart(2,'0')}m`; }
function fmtHrsMins(ms){ let s=Math.max(0, Math.floor(ms/1000)); const h=Math.floor(s/3600); const m=Math.floor((s%3600)/60); return `${h} hr${h===1?'':'s'} ${m} min${m===1?'':'s'}`; }
function dateAtMidnight(ts){ const d=new Date(ts); d.setHours(0,0,0,0); return d.getTime(); }
function todayKey(ts){ return dateAtMidnight(ts||Date.now()); }
function nextMidnight(ts){ const today = dateAtMidnight(ts||Date.now()); return today + 24*60*60*1000; }
function weekIndex(ts){ const base=ts||Date.now(); if(!state.startDate) return 0; return Math.floor((base-state.startDate)/(7*24*60*60*1000)); }
function currentWeekIdx(){ return weekIndex(Date.now()); }

/* ------------------ NUMERIC FORMATTING HELPERS ------------------ */
function num(x, def=null){ if(x === null || x === undefined) return def; const v=Number(x); return Number.isFinite(v)?v:def; }
function fmtN(x,d=1){ const v=num(x,null); return v===null?'‚Äî':v.toFixed(d); }
function fmtPct(frac,d=1){ const f=num(frac,null); return f===null?'‚Äî':(f*100).toFixed(d)+'%'; }
function weekStartTs(){ if(!state.startDate) return todayKey(Date.now()); const idx=currentWeekIdx(); const base=dateAtMidnight(state.startDate); return base + idx*7*86400000; }

/* ------------------ DURATION ------------------ */
function activeDuration(session){
  const endAt = session.end ?? Date.now();
  let total = Math.max(0, endAt - session.start);
  for(const p of (session.pauses||[])){
    const pe = p.end ?? Date.now();
    const ps = p.start ?? session.start;
    const a = Math.max(session.start, ps);
    const b = Math.min(endAt, pe);
    if(b > a) total -= (b - a);
  }
  return Math.max(0, total);
}

/* ------------------ FLAGS/TIMERS ------------------ */
let sessionActive=false, paused=false;
let rtTimer=null, autoTimer=null, tickId=null;

/* Recall system state */
let recallActive=false, recallType='cold', recallNotes=[], recallIndex=0;
let recallStream=null, recallRecorder=null, recallData=[];
function stopAllTimers(){ if(tickId){ clearInterval(tickId); tickId=null; } if(rtTimer){ clearTimeout(rtTimer); rtTimer=null; } if(autoTimer){ clearTimeout(autoTimer); autoTimer=null; }

/* one-shot suppression so strict modal doesn't appear right after specials */
}
let suppressStrictOnce=false;

/* ------------------ SANITY ------------------ */
function sealDanglingSession(){
  try{
    const rec = (state.sessions||[])[(state.sessions||[]).length - 1];
    if(!rec) return;
    if(rec.end == null){
      const now = Date.now();
      if(rec.pauses && rec.pauses.length){
        const last = rec.pauses[rec.pauses.length-1];
        if(last && !last.end) last.end = now;
      }
      rec.end = now; save();
    }
  }catch(e){ report(e); }
}

/* ------------------ UI ------------------ */
function showScreen(id){
  document.querySelectorAll('.screen').forEach(el=> el.style.display='none');
  if(id === 'menuScreen'){
    sessionActive=false; paused=false;
    stopAllTimers(); sealDanglingSession(); updateCapsUI();
    try{ populatePitchSelect(); drawChart(); }catch(_){}
  } else if(id !== 'trainerScreen'){
    if(sessionActive && !paused){ pauseStart('nav-away'); }
  }
  const el = byId(id); if(el) el.style.display='block';
}
function ensureWeekRoll(){ const wi=currentWeekIdx(); if(state.thisWeekIdx!==wi){ state.thisWeekIdx=wi; state.thisWeekMs=0; save(); } }
function isLocked(){ return state.lockoutUntil && Date.now() < state.lockoutUntil; }
function updateCapsUI(){
  ensureWeekRoll();
  const left = Math.max(0, SESS_DAILY_MS - msUsedQuota());
  text('capInfo', `Left: ${fmtMMSS(left)}`);
  const usedW = state.thisWeekMs || 0;
  const wp = byId('weekPill');
  if(wp){
    wp.textContent = `This week: ${fmtHrsMins(usedW)}`;
    let color = '#dc2626';
    if(usedW >= 1*3600000 && usedW < 2*3600000) color = 'var(--text)';
    else if(usedW >= 2*3600000 && usedW < 3*3600000) color = '#16a34a';
    else if(usedW >= 3*3600000) color = '#fbbf24';
    wp.style.color = color;
    wp.title = `Target: ${fmtHMM(WEEKLY_TARGET_MS)}`;
  }
  const locked = isLocked();
  const lp = byId('lockoutPill');
  if(lp){
    if(locked){ 
      const timeLeft = state.lockoutUntil - Date.now();
      const message = timeLeft > 12*60*60*1000 ? 'üîí Come back tomorrow' : `üîí Locked (${fmtHMM(timeLeft)} left)`;
      lp.style.display='inline-flex'; 
      lp.textContent = message; 
    }
    else lp.style.display='none';
  }
  const pf = byId('playFlappy'); if(pf) pf.disabled = !locked;
}
function setFromIndex(i){return Math.floor((i-1)/LEVELS_PER_SET)+1;}
function blockFromIndex(i){return ((i-1)%LEVELS_PER_SET)+1;}
function thresholdForIndex(i){return THRESH_24[blockFromIndex(i)-1];}
function trainedSet(k){ return UNLOCK_ORDER.slice(0,k); }

/* ------------------ AUDIO ------------------ */
let ACTX=null; const BUF_CACHE=new Map();
function getCtx(){ if(!ACTX){ ACTX=new (window.AudioContext||window.webkitAudioContext)(); } return ACTX; }
async function resumeCtx(){ try{ const ctx=getCtx(); if(ctx.state==='suspended') await ctx.resume(); }catch(e){ report(e); } }
async function loadBuffer(url){ if(BUF_CACHE.has(url)) return BUF_CACHE.get(url); const res=await fetch(url); if(!res.ok) throw new Error('Missing audio '+url); const arr=await res.arrayBuffer(); const buf=await getCtx().decodeAudioData(arr); BUF_CACHE.set(url,buf); return buf; }
async function closeAudio(){ try{ if(ACTX){ await ACTX.close(); } }catch(_){} finally{ ACTX=null; BUF_CACHE.clear(); } }

/* Guitar sample mapping - available samples and their pitches */
const GUITAR_SAMPLES = {
  'E2': 'E2.wav', 'A2': 'A2.wav', 'D3': 'D3.wav', 
  'G3': 'G3.wav', 'B3': 'B3.wav', 'E4': 'E4.wav', 'A4': 'A4.wav'
};

/* Find closest guitar sample for pitch shifting */
function findClosestGuitarSample(targetNote) {
  const m=/^([A-G](?:b)?)(\d)$/.exec(targetNote);
  const pc=m?m[1]:'A', o=m?+m[2]:4;
  const idx={C:0,Db:1,D:2,Eb:3,E:4,F:5,Gb:6,G:7,Ab:8,A:9,Bb:10,B:11};
  const targetSemis=(idx[pc]??9)+(o-4)*12;
  
  let bestSample = 'E2';
  let bestDistance = 999;
  
  for (const sampleNote of Object.keys(GUITAR_SAMPLES)) {
    const sm=/^([A-G](?:b)?)(\d)$/.exec(sampleNote);
    const spc=sm?sm[1]:'E', so=sm?+sm[2]:2;
    const sampleSemis=(idx[spc]??4)+(so-4)*12;
    const distance = Math.abs(targetSemis - sampleSemis);
    if (distance < bestDistance) {
      bestDistance = distance;
      bestSample = sampleNote;
    }
  }
  
  return { sample: bestSample, semitones: targetSemis - ((idx[bestSample.match(/^([A-G](?:b)?)/)[1]]??4)+((+bestSample.match(/(\d)$/)[1])-4)*12) };
}

/* Always play a tone (sample -> oscillator -> fallback) */
async function playSample(note, jitterCents = 0, forceTimbre = null){
  // Skip audio during simulation
  if (SIMULATING) return;
  
  try{
    await resumeCtx();
    const ctx = getCtx();
    
    // Determine which timbre to use
    const noteWithoutOctave = note.replace(/\d/, '');
    const preferredTimbre = forceTimbre || state.audioType;
    const actualTimbre = forceTimbre || getTimbreForTrial(preferredTimbre, noteWithoutOctave);
    
    // Store the timbre used for this trial
    currentTrialTimbre = actualTimbre;
    
    // Handle different audio types
    if (actualTimbre === AUDIO_TYPES.PIANO) {
      try{
        const url = `${AUDIO_PIANO}/${note}.mp3`;
        const buf = await loadBuffer(url);
        const src = ctx.createBufferSource();
        src.buffer = buf;
        
        // Apply jitter via playback rate if specified
        if (jitterCents !== 0) {
          const pitchRatio = Math.pow(2, jitterCents / 1200);
          src.playbackRate.value = pitchRatio;
        }
        
        const g = ctx.createGain(); g.gain.value = 1;
        src.connect(g).connect(ctx.destination);
        const t = ctx.currentTime;
        const duration = jitterCents !== 0 ? TONE_MS/1000 / src.playbackRate.value : TONE_MS/1000;
        src.start(t); src.stop(t + duration);
        return;
      }catch(_e){}
    } else if (actualTimbre === AUDIO_TYPES.GUITAR) {
      try{
        const {sample, semitones} = findClosestGuitarSample(note);
        const url = `${AUDIO_GUITAR}/${GUITAR_SAMPLES[sample]}`;
        const buf = await loadBuffer(url);
        const src = ctx.createBufferSource();
        src.buffer = buf;
        
        // Apply pitch shifting with jitter
        const basePitchRatio = Math.pow(2, semitones / 12);
        const jitterRatio = jitterCents !== 0 ? Math.pow(2, jitterCents / 1200) : 1;
        src.playbackRate.value = basePitchRatio * jitterRatio;
        
        // Guitar samples are louder, so reduce gain
        const g = ctx.createGain(); 
        g.gain.value = 0.7; // Reduce guitar volume
        
        src.connect(g).connect(ctx.destination);
        const t = ctx.currentTime;
        src.start(t); src.stop(t + TONE_MS/1000 / src.playbackRate.value);
        return;
      }catch(_e){}
    } else if (actualTimbre === AUDIO_TYPES.SINE) {
      // Skip to sine wave generation
    } else {
      // Default to piano, fallback to sine
      try{
        const url = `${AUDIO_PIANO}/${note}.mp3`;
        const buf = await loadBuffer(url);
        const src = ctx.createBufferSource();
        src.buffer = buf;
        
        // Apply jitter via playback rate if specified
        if (jitterCents !== 0) {
          const pitchRatio = Math.pow(2, jitterCents / 1200);
          src.playbackRate.value = pitchRatio;
        }
        
        const g = ctx.createGain(); g.gain.value = 1;
        src.connect(g).connect(ctx.destination);
        const t = ctx.currentTime;
        const duration = jitterCents !== 0 ? TONE_MS/1000 / src.playbackRate.value : TONE_MS/1000;
        src.start(t); src.stop(t + duration);
        return;
      }catch(_e){}
    }
    
    // Fallback to sine wave
    const m=/^([A-G](?:b)?)(\d)$/.exec(note);
    const pc=m?m[1]:'A', o=m?+m[2]:4;
    const idx={C:0,Db:1,D:2,Eb:3,E:4,F:5,Gb:6,G:7,Ab:8,A:9,Bb:10,B:11};
    const semis=(idx[pc]??9)+(o-4)*12;
    let freq=440*Math.pow(2,(semis-9)/12);
    
    // Apply jitter to frequency
    if (jitterCents !== 0) {
      freq = freq * Math.pow(2, jitterCents / 1200);
    }
    
    const osc = ctx.createOscillator(); const g = ctx.createGain();
    osc.type='sine'; osc.frequency.value=freq;
    const t0 = ctx.currentTime;
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.linearRampToValueAtTime(0.25, t0 + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + TONE_MS/1000);
    osc.connect(g).connect(ctx.destination);
    osc.start(t0); osc.stop(t0 + TONE_MS/1000);
  }catch(e){
    try{
      const ctx=getCtx(); const osc=ctx.createOscillator(); const g=ctx.createGain();
      osc.type='sine'; osc.frequency.value=440;
      const t0=ctx.currentTime; g.gain.setValueAtTime(0.0001,t0); g.gain.linearRampToValueAtTime(0.2,t0+0.01); g.gain.exponentialRampToValueAtTime(0.0001,t0+0.3);
      osc.connect(g).connect(ctx.destination); osc.start(t0); osc.stop(t0+0.3);
    }catch(_){}
  }
}

/* Flappy sound for Flappy Bird lockout */
async function playFlappySound(){
  try{
    await resumeCtx();
    const ctx = getCtx();
    const url = `${AUDIO_PIANO}/flappy.mp3`;
    const buf = await loadBuffer(url);
    const src = ctx.createBufferSource();
    src.buffer = buf;
    const g = ctx.createGain(); 
    g.gain.value = 0.8; // Set volume level
    src.connect(g).connect(ctx.destination);
    const t = ctx.currentTime;
    src.start(t);
  }catch(_e){}
}





function selectInBoundsNote(usableNotes) {
  if (usableNotes.length === 0) return 'F'; // Fallback
  
  // D) CURRICULUM/SCHEDULER LOGGING - Update active pitches
  updateCurriculumState(usableNotes);
  
  // Use new weight calculation system
  const weights = calculateSelectionWeights(usableNotes);
  
  // D) CURRICULUM/SCHEDULER LOGGING - Store current weights (fractions)
  const totalWeight = Object.values(weights).reduce((a, b) => a + b, 0);
  state.curriculum.weights = {};
  usableNotes.forEach(note => {
    state.curriculum.weights[note] = totalWeight > 0 ? weights[note] / totalWeight : 1.0 / usableNotes.length;
  });
  
  // Weighted random selection
  let random = Math.random() * totalWeight;
  
  let selectedNote = null;
  for (const [note, weight] of Object.entries(weights)) {
    random -= weight;
    if (random <= 0) {
      selectedNote = note;
      break;
    }
  }
  
  if (!selectedNote) {
    selectedNote = rand(usableNotes); // Fallback to random
  }
  
  // Log weights trace before each block
  logWeightsTrace(usableNotes, selectedNote);
  
  return selectedNote;
}

// D) CURRICULUM/SCHEDULER LOGGING - Update curriculum state
function updateCurriculumState(usableNotes) {
  // Update active pitches
  state.curriculum.active = [...usableNotes].sort();
  
  // Check for new pitches being added
  const currentDay = Math.floor((Date.now() - (state.startDate || Date.now())) / (24 * 60 * 60 * 1000)) + 1;
  const previousActive = state.curriculum.previousActive || [];
  
  const newPitches = usableNotes.filter(note => !previousActive.includes(note));
  newPitches.forEach(note => {
    state.curriculum.events.push({
      day: currentDay,
      type: "addPitch",
      details: { pitch: note, totalActive: usableNotes.length }
    });
  });
  
  state.curriculum.previousActive = [...usableNotes];
}

/* ------------------ CONFUSION MATRIX & SCHEDULING ------------------ */
function updateConfusionMatrix(truePc, guessPc) {
  if (!state.confusionMatrix) {
    // Initialize 12x12 matrix
    state.confusionMatrix = {};
    PC.forEach(pc1 => {
      state.confusionMatrix[pc1] = {};
      PC.forEach(pc2 => {
        state.confusionMatrix[pc1][pc2] = 0;
      });
    });
  }
  
  // Initialize qa.confusion.matrix if needed
  if (!state.qa.confusion.matrix) {
    state.qa.confusion.matrix = {};
    PC.forEach(pc1 => {
      state.qa.confusion.matrix[pc1] = {};
      PC.forEach(pc2 => {
        state.qa.confusion.matrix[pc1][pc2] = 0;
      });
    });
  }
  
  // Update both matrices (legacy and qa formats)
  if (state.confusionMatrix[truePc] && state.confusionMatrix[truePc][guessPc] !== undefined) {
    state.confusionMatrix[truePc][guessPc]++;
    state.qa.confusion.matrix[truePc][guessPc]++;
  }
}

function getConfusionPairs() {
  // Return the most confused note pairs for targeted training
  if (!state.confusionMatrix) return [];
  
  const pairs = [];
  PC.forEach(truePc => {
    PC.forEach(guessPc => {
      if (truePc !== guessPc && state.confusionMatrix[truePc] && state.confusionMatrix[truePc][guessPc] > 0) {
        pairs.push({
          truePc,
          guessPc,
          count: state.confusionMatrix[truePc][guessPc]
        });
      }
    });
  });
  
  return pairs.sort((a, b) => b.count - a.count).slice(0, 3); // Top 3 confusion pairs
}

// Log selection weights before each block
function logWeightsTrace(usableNotes, selectedNote) {
  const currentBlock = blockFromIndex(state.levelIndex);
  
  if (!state.weightsTrace) state.weightsTrace = [];
  
  // Calculate weights for this selection
  const weights = calculateSelectionWeights(usableNotes);
  
  // Get top 3 notes by weight
  const sortedWeights = Object.entries(weights)
    .sort(([,a], [,b]) => b - a)
    .slice(0, 3);
  
  // Determine reason for selection
  let reason = 'random';
  const weakNotes = getWeakNotes().map(w => w.note);
  const confusionPairs = getConfusionPairs();
  
  if (weakNotes.includes(selectedNote)) {
    reason = 'weak-note';
  } else if (confusionPairs.some(p => p.truePc === selectedNote)) {
    reason = 'confusion-target';
  }
  
  state.weightsTrace.push({
    block: currentBlock,
    set: setFromIndex(state.levelIndex),
    selectedNote: selectedNote,
    topWeights: sortedWeights.map(([note, weight]) => ({
      note,
      weight: Math.round(weight * 100) / 100
    })),
    reason: reason,
    timestamp: Date.now()
  });
}

function calculateSelectionWeights(usableNotes) {
  if (usableNotes.length === 0) return {};
  
  // Get weak notes and confusion pairs
  const weakNotes = getWeakNotes().map(w => w.note);
  const confusionPairs = getConfusionPairs();
  
  // D) CURRICULUM/SCHEDULER LOGGING - Check for boost events
  const currentDay = Math.floor((Date.now() - (state.startDate || Date.now())) / (24 * 60 * 60 * 1000)) + 1;
  
  // Create weighted selection
  const weights = {};
  const baseWeight = 1; // Minimum weight for all notes
  
  // Initialize all notes with base weight
  usableNotes.forEach(note => {
    weights[note] = baseWeight;
  });
  
  // Boost weight for weak notes
  if (weakNotes.length > 0) {
    weakNotes.forEach(note => {
      if (weights[note] !== undefined) {
        weights[note] += 2; // +2 weight for weak notes
      }
    });
    
    // Log boostWeak event
    state.curriculum.events.push({
      day: currentDay,
      type: "boostWeak",
      details: { pitches: weakNotes, boost: 2.0 }
    });
  }
  
  // Boost weight for notes in top confusion pairs
  confusionPairs.forEach(pair => {
    if (weights[pair.truePc] !== undefined) {
      weights[pair.truePc] += 1.5; // +1.5 weight for confusion targets
      
      // Check if this confusion pair accounts for ‚â•20% of the pitch's errors
      const pitchErrors = getPitchErrorRate(pair.truePc);
      const confusionRate = pair.rate || 0;
      
      if (confusionRate >= 0.20) {
        // Log boostConfusion event and increase weight modestly for 1 block
        state.curriculum.events.push({
          day: currentDay,
          type: "boostConfusion",
          details: { 
            truePc: pair.truePc, 
            guessPc: pair.guessPc, 
            confusionRate: confusionRate,
            temporaryBoost: 1.5 
          }
        });
      }
    }
  });
  
  return weights;
}

function getWeakNotes() {
  // Return notes that need more training based on recent performance
  if (!state.noteStats) return [];
  
  const weakNotes = Object.entries(state.noteStats)
    .filter(([note, stats]) => {
      return stats.trials.length >= 10 && (
        stats.accuracy < 0.75 || 
        stats.medianError > 25
      );
    })
    .map(([note, stats]) => ({ note, accuracy: stats.accuracy, medianError: stats.medianError }))
    .sort((a, b) => a.accuracy - b.accuracy);
  
  return weakNotes.slice(0, 3); // Top 3 weak notes
}

// D) CURRICULUM/SCHEDULER LOGGING - Get pitch error rate for confusion analysis
function getPitchErrorRate(truePc) {
  if (!state.confusionMatrix || !state.confusionMatrix[truePc]) return 0;
  
  const pitchData = state.confusionMatrix[truePc];
  const totalErrors = Object.values(pitchData).reduce((sum, count) => sum + count, 0);
  const correctCount = pitchData[truePc] || 0;
  const incorrectCount = totalErrors - correctCount;
  
  return totalErrors > 0 ? incorrectCount / totalErrors : 0;
}

// C) JITTER LADDER LOGGING - Generate daily pitch snapshots
function generateDailyJitterSnapshot() {
  const currentDay = Math.floor((Date.now() - (state.startDate || Date.now())) / (24 * 60 * 60 * 1000)) + 1;
  
  // Only generate once per day
  if (state.jitter.lastSnapshotDay === currentDay) return;
  
  state.jitter.byPitch = {}; // Reset daily snapshot
  
  PC.forEach(pc => {
    initializeJitterLevel(pc);
    initializeNoteStats(pc);
    
    const level = state.jitterLevels[pc];
    const config = JITTER_LEVELS[level];
    const stats = state.noteStats[pc];
    
    // Calculate shares
    const anchorsPct = num(config.anchorRate, 0);
    const probesPct = num(config.probeRate, 0);
    const jitterPct = num(1.0 - config.anchorRate - config.probeRate, 0);
    
    state.jitter.byPitch[pc] = {
      JL: level,
      anchorsPct: anchorsPct,
      probesPct: probesPct,
      jitterPct: jitterPct,
      jitterRange: `¬±${config.jitterRange[0]}-${config.jitterRange[1]}¬¢`,
      acc: stats.trials.length > 0 ? num(stats.accuracy, null) : null,
      medianCents: stats.trials.length > 0 ? num(stats.medianError, null) : null,
      sdCents: stats.trials.length > 0 ? num(stats.sdError, null) : null
    };
  });
  
  state.jitter.lastSnapshotDay = currentDay;
  save();
}

function updateJitterStatusUI(set) {
  const trainedNotes = trainedSet(set);
  if (trainedNotes.length === 0) return;
  
  // Get average jitter level across trained notes
  const levels = trainedNotes.map(note => {
    initializeJitterLevel(note);
    return state.jitterLevels[note];
  });
  
  const levelCounts = levels.reduce((acc, level) => {
    acc[level] = (acc[level] || 0) + 1;
    return acc;
  }, {});
  
  // Show most common level
  const mostCommon = Object.entries(levelCounts)
    .sort(([,a], [,b]) => b - a)[0];
  
  if (mostCommon) {
    textWithTooltip('jitterInfo', `Jitter: ${mostCommon[0]}`);
    byId('jitterInfo').style.display = 'inline-flex';
  }
}

function updateOctaveStatusUI() {
  initializeOctaveState();
  const mix = state.octaveStats.currentMix;
  const centerPct = Math.round(mix.center * 100);
  const neighborPct = Math.round(mix.neighbors * 100);
  
  textWithTooltip('octaveInfo', `Mix: ${centerPct}/${neighborPct}`);
  byId('octaveInfo').style.display = 'inline-flex';
}

function updateVarietyModeUI() {
  const label = byId('varietyModeLabel');
  const toggle = byId('varietyModeToggle');
  
  if (!label || !toggle) return;
  
  if (!state.startDate) {
    label.textContent = "Will activate after week 3";
    return;
  }
  
  const weeksSinceStart = Math.floor((Date.now() - state.startDate) / (7 * 24 * 60 * 60 * 1000));
  
  if (weeksSinceStart < 3) {
    label.textContent = `Will activate in ${3 - weeksSinceStart} week(s)`;
  } else if (state.varietyModeEnabled && shouldUseVarietyMode()) {
    label.textContent = "Active: 80%/20% mix";
  } else if (state.varietyModeEnabled) {
    label.textContent = "Enabled, will activate week 3+";
  } else {
    label.textContent = "Available now - click to enable";
  }
}

function updateDebugInfo() {
  const content = byId('debugContent');
  if (!content) return;
  
  const info = [];
  
  // System state
  info.push(`=== SYSTEM STATE ===`);
  info.push(`Session Active: ${sessionActive}`);
  info.push(`Current Level: ${state.levelIndex} (Set ${setFromIndex(state.levelIndex)}, Block ${blockFromIndex(state.levelIndex)})`);
  info.push(`Variety Mode: ${state.varietyModeEnabled} (Active: ${shouldUseVarietyMode()})`);
  
  // Jitter levels
  if (state.jitterLevels && Object.keys(state.jitterLevels).length > 0) {
    info.push(`\n=== JITTER LEVELS ===`);
    Object.entries(state.jitterLevels).forEach(([note, level]) => {
      const stats = state.noteStats?.[note];
      const acc = stats ? fmtPct(stats.accuracy, 0) : 'N/A';
      const err = stats ? fmtN(stats.medianError, 0) + '¬¢' : 'N/A';
      info.push(`${note}: ${level} (${acc}% acc, ${err}¬¢ err)`);
    });
  }
  
  // OOB state
  if (state.oobStats) {
    info.push(`\n=== OOB SYSTEM ===`);
    info.push(`Adaptive Rate: ${fmtPct(state.oobStats.adaptiveRate, 1)}`);
    info.push(`Streak Count: ${state.oobStats.streakCount}`);
    info.push(`Health Check: ${state.oobStats.healthCheckActive}`);
    info.push(`Recent Trials: ${state.oobStats.recentTrials.length}/60`);
  }
  
  // Octave mixing
  if (state.octaveStats) {
    info.push(`\n=== OCTAVE MIXING ===`);
    const mix = state.octaveStats.currentMix;
    info.push(`Current Mix: ${fmtPct(mix.center, 0)} center, ${fmtPct(mix.neighbors, 0)} neighbors`);
    info.push(`Set Trials: ${state.octaveStats.setTrials.length}/24`);
  }
  
  // Timbre state
  if (state.timbreStats && shouldUseVarietyMode()) {
    info.push(`\n=== TIMBRE VARIETY ===`);
    info.push(`Daily Alternate: ${state.timbreStats.dailyAlternate || 'None'}`);
    info.push(`Last Rotation: ${state.timbreStats.lastRotation || 'Never'}`);
  }
  
  content.textContent = info.join('\n');
}

/* ------------------ ENHANCED AUDIO WITH JITTER ------------------ */
// Simplified pitch detection using autocorrelation
function detectPitch(audioBuffer) {
  const sampleRate = audioBuffer.sampleRate;
  const buffer = audioBuffer.getChannelData(0);
  const bufferSize = buffer.length;
  
  // Basic autocorrelation for pitch detection
  const minPeriod = Math.floor(sampleRate / 800); // ~800 Hz max
  const maxPeriod = Math.floor(sampleRate / 80);  // ~80 Hz min
  
  let bestCorrelation = 0;
  let bestPeriod = 0;
  
  for (let period = minPeriod; period < maxPeriod && period < bufferSize / 2; period++) {
    let correlation = 0;
    for (let i = 0; i < bufferSize - period; i++) {
      correlation += buffer[i] * buffer[i + period];
    }
    
    if (correlation > bestCorrelation) {
      bestCorrelation = correlation;
      bestPeriod = period;
    }
  }
  
  if (bestPeriod === 0) return null;
  
  const frequency = sampleRate / bestPeriod;
  return frequency;
}

function frequencyToCents(freq, referenceFreq = 440) {
  if (!freq || freq <= 0) return null;
  return Math.round(1200 * Math.log2(freq / referenceFreq));
}

function centsToNoteName(cents) {
  // A4 = 440Hz = 0 cents reference
  const noteNames = ['A', 'Bb', 'B', 'C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab'];
  const semitonesFromA = Math.round(cents / 100);
  const noteIndex = ((semitonesFromA % 12) + 12) % 12;
  return noteNames[noteIndex];
}

function targetNoteToCents(note) {
  // Convert note name to cents offset from A4, considering closest octave F1-F7
  const noteOffsets = {A: 0, Bb: 100, B: 200, C: 300, Db: 400, D: 500, Eb: 600, E: 700, F: 800, Gb: 900, G: 1000, Ab: 1100};
  const baseCents = noteOffsets[note] || 0;
  
  // Return array of possible target cents for octaves 1-7
  const possibleCents = [];
  for (let octave = 1; octave <= 7; octave++) {
    const octaveCents = baseCents + (octave - 4) * 1200; // A4 is reference (0 cents)
    possibleCents.push(octaveCents);
  }
  
  return possibleCents;
}

async function startRecallTest(type = 'cold') {
  if (!state.userName) return;
  
  recallType = type;
  recallActive = true;
  recallIndex = 0;
  recallData = [];
  
  // Determine which notes to test (2-3 learned notes)
  const set = setFromIndex(state.levelIndex);
  const learnedNotes = trainedSet(Math.min(set, 3)); // Use first 2-3 learned notes
  recallNotes = learnedNotes.slice(0, Math.min(3, learnedNotes.length));
  
  if (recallNotes.length === 0) {
    // No learned notes yet, skip recall
    if (type === 'cold') startTrainingDirectly();
    return;
  }
  
  // Update modal
  document.getElementById('recallTitle').textContent = type === 'cold' ? 'üåÖ Cold Recall Test' : 'üî• Warm Recall Test';
  document.getElementById('recallInstruction').textContent = 
    type === 'cold' 
      ? 'Before training, please sing/hum the following notes to test your pitch memory:'
      : 'After training, please sing/hum the following notes again:';
  
  updateRecallUI();
  document.getElementById('recallModal').style.display = 'flex';
}

function updateRecallUI() {
  if (!recallActive || recallIndex >= recallNotes.length) return;
  
  const currentNote = recallNotes[recallIndex];
  document.getElementById('recallCounter').textContent = `Note ${recallIndex + 1} of ${recallNotes.length}`;
  document.getElementById('recallCurrentNote').textContent = pcLabel(currentNote);
  document.getElementById('recallTargetNote').textContent = pcLabel(currentNote);
  
  // Reset UI state
  document.getElementById('recallFeedback').style.display = 'none';
  document.getElementById('btnStartRecording').style.display = 'inline-block';
  document.getElementById('btnStopRecording').style.display = 'none';
  document.getElementById('btnNextRecall').style.display = 'none';
  document.getElementById('btnFinishRecall').style.display = 'none';
}

async function startRecallRecording() {
  try {
    // Request microphone access
    recallStream = await navigator.mediaDevices.getUserMedia({ 
      audio: { 
        sampleRate: RECALL_SAMPLE_RATE,
        channelCount: 1,
        echoCancellation: false,
        noiseSuppression: false 
      } 
    });
    
    const audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: RECALL_SAMPLE_RATE });
    const source = audioContext.createMediaStreamSource(recallStream);
    
    // Use MediaRecorder for simplicity
    recallRecorder = new MediaRecorder(recallStream);
    const chunks = [];
    
    recallRecorder.ondataavailable = (event) => {
      chunks.push(event.data);
    };
    
    recallRecorder.onstop = async () => {
      const blob = new Blob(chunks, { type: 'audio/wav' });
      const arrayBuffer = await blob.arrayBuffer();
      const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
      processRecallRecording(audioBuffer);
      
      // Clean up
      recallStream.getTracks().forEach(track => track.stop());
      recallStream = null;
      audioContext.close();
    };
    
    // Update UI
    document.getElementById('btnStartRecording').style.display = 'none';
    document.getElementById('btnStopRecording').style.display = 'inline-block';
    
    // Start recording
    recallRecorder.start();
    
    // Auto-stop after 2 seconds
    setTimeout(() => {
      if (recallRecorder && recallRecorder.state === 'recording') {
        recallRecorder.stop();
      }
    }, RECALL_DURATION_MS);
    
  } catch (error) {
    console.error('Error accessing microphone:', error);
    alert('Could not access microphone. Please check permissions and try again.');
    document.getElementById('btnStartRecording').style.display = 'inline-block';
    document.getElementById('btnStopRecording').style.display = 'none';
  }
}

function stopRecallRecording() {
  if (recallRecorder && recallRecorder.state === 'recording') {
    recallRecorder.stop();
  }
}

function processRecallRecording(audioBuffer) {
  const targetNote = recallNotes[recallIndex];
  const possibleTargetCents = targetNoteToCents(targetNote);
  
  // Analyze multiple segments of the recording for better accuracy
  const segmentSize = Math.floor(audioBuffer.length / 4);
  const frequencies = [];
  
  for (let i = 0; i < 4; i++) {
    const start = i * segmentSize;
    const segmentBuffer = audioBuffer.getChannelData(0).slice(start, start + segmentSize);
    const segmentAudioBuffer = {
      sampleRate: audioBuffer.sampleRate,
      getChannelData: () => segmentBuffer,
      length: segmentBuffer.length
    };
    
    const freq = detectPitch(segmentAudioBuffer);
    if (freq && freq > 80 && freq < 800) {
      frequencies.push(freq);
    }
  }
  
  if (frequencies.length === 0) {
    showRecallResult('No clear pitch detected. Please try again.', null, null);
    return;
  }
  
  // Calculate median frequency and convert to cents
  frequencies.sort((a, b) => a - b);
  const medianFreq = frequencies[Math.floor(frequencies.length / 2)];
  const detectedCents = frequencyToCents(medianFreq);
  
  // Find the closest target octave
  let closestTargetCents = possibleTargetCents[0];
  let smallestError = Math.abs(detectedCents - possibleTargetCents[0]);
  
  for (const targetCents of possibleTargetCents) {
    const error = Math.abs(detectedCents - targetCents);
    if (error < smallestError) {
      smallestError = error;
      closestTargetCents = targetCents;
    }
  }
  
  const centsError = detectedCents - closestTargetCents;
  
  // Calculate standard deviation
  const avgCents = frequencies.map(f => frequencyToCents(f));
  const mean = avgCents.reduce((a, b) => a + b, 0) / avgCents.length;
  const variance = avgCents.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / avgCents.length;
  const stdDev = Math.sqrt(variance);
  
  // Determine verdict
  let verdict;
  const absError = Math.abs(centsError);
  if (absError <= 10 && stdDev <= 15) {
    verdict = 'On target';
  } else if (absError <= 30) {
    verdict = 'Close';
  } else {
    verdict = 'Off';
  }
  
  // Store result
  const result = {
    note: targetNote,
    type: recallType,
    date: Date.now(),
    medianCents: detectedCents,
    centsError: centsError,
    stdDev: stdDev,
    verdict: verdict,
    frequency: medianFreq
  };
  
  recallData.push(result);
  state.recallResults.push(result);
  save();
  
  showRecallResult(`${Math.abs(centsError)} cents ${centsError >= 0 ? 'sharp' : 'flat'}`, verdict, centsError);
}

function showRecallResult(message, verdict, centsError) {
  const feedbackDiv = document.getElementById('recallFeedback');
  const resultsDiv = document.getElementById('recallResults');
  const verdictDiv = document.getElementById('recallVerdict');
  
  resultsDiv.textContent = message;
  verdictDiv.textContent = verdict ? `Verdict: ${verdict}` : '';
  
  // Color code the result
  if (verdict === 'On target') {
    resultsDiv.style.color = 'var(--good)';
  } else if (verdict === 'Close') {
    resultsDiv.style.color = 'var(--accent)';
  } else {
    resultsDiv.style.color = 'var(--bad)';
  }
  
  feedbackDiv.style.display = 'block';
  
  // Show appropriate next button
  if (recallIndex < recallNotes.length - 1) {
    document.getElementById('btnNextRecall').style.display = 'inline-block';
  } else {
    document.getElementById('btnFinishRecall').style.display = 'inline-block';
  }
}

function nextRecallNote() {
  recallIndex++;
  if (recallIndex >= recallNotes.length) {
    finishRecallTest();
  } else {
    updateRecallUI();
  }
}

function skipRecallTest() {
  recallActive = false;
  document.getElementById('recallModal').style.display = 'none';
  
  if (recallType === 'cold') {
    startTrainingDirectly();
  } else {
    // Warm recall finished, show session complete
    alert('Training session complete!');
    showScreen('menuScreen');
  }
}

function finishRecallTest() {
  recallActive = false;
  document.getElementById('recallModal').style.display = 'none';
  
  if (recallType === 'cold') {
    state.coldRecallDone = true;
    save();
    startTrainingDirectly();
  } else {
    state.warmRecallDone = true;
    save();
    alert('Training session and warm recall complete!');
    showScreen('menuScreen');
  }
}

/* ------------------ TRAINING FLOW ------------------ */
let autoNext=false, delayMs=1000;
let currentNote=null, truePc=null, isOOBTrial=false;
let currentTrialJitter=null; // Track jitter info for current trial
let currentTrialTimbre=null; // Track timbre used for current trial
let firstRtBonusMs=0, inFlightTrial=false;
let suggestedRestartFlag=false;

/* Specials runtime */
let special=null; // {mode:'A'|'B', targetPc:'F', total:12|22, done:0, withFeedback:true, correct:0}

/* Assessment runtime */
let assessmentActive=false, assessmentTrials=[], assessmentCurrentTrial=0;

const PC2I={C:0,Db:1,D:2,Eb:3,E:4,F:5,Gb:6,G:7,Ab:8,A:9,Bb:10,B:11};
function currentOOBs(setSize){
  if(setSize>=12) return [];
  const learned = trainedSet(setSize).map(n=>PC2I[n]).sort((a,b)=>a-b);
  const low=learned[0], high=learned[learned.length-1];
  const up1=(high+1)%12, up2=(high+2)%12, dn1=(low+11)%12, dn2=(low+10)%12;
  const out=[];
  if(!learned.includes(up1)) out.push(PC[up1]);
  if(!learned.includes(up2) && !learned.includes(up1)) out.push(PC[up2]);
  if(!learned.includes(dn1)) out.push(PC[dn1]);
  if(!learned.includes(dn2) && !learned.includes(dn1)) out.push(PC[dn2]);
  return out;
}
function getPlusMinusTwoSemitones(targetPc){
  const targetIndex = PC2I[targetPc];
  if (targetIndex === undefined) return [targetPc]; // fallback
  
  const pitches = [];
  for (let offset = -2; offset <= 2; offset++) {
    const index = (targetIndex + offset + 12) % 12;
    pitches.push(PC[index]);
  }
  return pitches;
}
/* ------------------ TIMBRE VARIETY SYSTEM ------------------ */
function initializeTimbreState() {
  if (!state.timbreStats) {
    state.timbreStats = {
      weekStarted: null,
      dailyAlternate: null,
      lastRotation: null,
      perTimbreRescue: {} // Track per-timbre performance for rescue
    };
  }
}

function shouldUseVarietyMode() {
  if (!state.varietyModeEnabled) return false;
  
  initializeTimbreState();
  
  // Check if we've been training for 3+ weeks
  if (!state.startDate) return false;
  
  const weeksSinceStart = Math.floor((Date.now() - state.startDate) / (7 * 24 * 60 * 60 * 1000));
  return weeksSinceStart >= 3;
}

function getTimbreForTrial(preferredTimbre, note) {
  if (!shouldUseVarietyMode()) {
    return preferredTimbre;
  }
  
  initializeTimbreState();
  
  // Check if we need to rotate daily alternate
  const today = Math.floor(Date.now() / (24 * 60 * 60 * 1000));
  if (state.timbreStats.lastRotation !== today) {
    // Rotate to different timbre
    const timbres = [AUDIO_TYPES.PIANO, AUDIO_TYPES.SINE, AUDIO_TYPES.GUITAR];
    const alternates = timbres.filter(t => t !== preferredTimbre);
    state.timbreStats.dailyAlternate = rand(alternates);
    state.timbreStats.lastRotation = today;
    save();
  }
  
  // Check for per-timbre rescue
  const noteTimbreKey = `${note}-${preferredTimbre}`;
  const alternateTimbreKey = `${note}-${state.timbreStats.dailyAlternate}`;
  
  const preferredStats = state.timbreStats.perTimbreRescue[noteTimbreKey];
  const alternateStats = state.timbreStats.perTimbreRescue[alternateTimbreKey];
  
  // If this note is weak on the alternate timbre, give it more examples
  if (alternateStats && (alternateStats.accuracy < 0.70 || alternateStats.medianError > 30)) {
    return state.timbreStats.dailyAlternate;
  }
  
  // Week 3+: 80% chosen timbre, 20% alternate
  return Math.random() < 0.80 ? preferredTimbre : state.timbreStats.dailyAlternate;
}

function updateTimbreStats(timbre, note, correct, centsError = 0) {
  if (!shouldUseVarietyMode()) return;
  
  initializeTimbreState();
  
  const key = `${note}-${timbre}`;
  if (!state.timbreStats.perTimbreRescue[key]) {
    state.timbreStats.perTimbreRescue[key] = {
      trials: [],
      accuracy: 0,
      medianError: 0
    };
  }
  
  const stats = state.timbreStats.perTimbreRescue[key];
  stats.trials.push({ correct, centsError, timestamp: Date.now() });
  
  // Keep last 20 trials
  if (stats.trials.length > 20) {
    stats.trials = stats.trials.slice(-20);
  }
  
  // Update metrics
  stats.accuracy = stats.trials.filter(t => t.correct).length / stats.trials.length;
  const errors = stats.trials.map(t => Math.abs(t.centsError || 0));
  errors.sort((a, b) => a - b);
  stats.medianError = errors.length > 0 ? errors[Math.floor(errors.length / 2)] : 0;
  
  save();
}

/* ------------------ OCTAVE MIXING SYSTEM ------------------ */
function initializeOctaveState() {
  if (!state.octaveStats) {
    state.octaveStats = {
      currentMix: { center: 0.90, neighbors: 0.10 }, // Start with 90/10
      centerOctave: 4, // Default center octave
      trialCount: 0,
      setTrials: [], // Current set's trial data
      performanceWindows: {
        window8_12: null,
        window12_16: null, 
        window16_20: null,
        window20_24: null
      }
    };
  }
  
  // Ensure all properties exist even if state.octaveStats was partially initialized
  state.octaveStats.currentMix ??= { center: 0.90, neighbors: 0.10 };
  state.octaveStats.centerOctave ??= 4;
  state.octaveStats.trialCount ??= 0;
  state.octaveStats.setTrials ??= [];
  state.octaveStats.performanceWindows ??= {
    window8_12: null,
    window12_16: null, 
    window16_20: null,
    window20_24: null
  };
}

function getOctaveRange() {
  // All audio types now use octaves 3-5
  return [3, 4, 5];
}

// Track octave distribution for OOB mirroring verification
function getInBoundsOctaveDistribution(windowSize = 40) {
  const recentTrials = state.trials.filter(t => !t.oob).slice(-windowSize);
  const distribution = { 3: 0, 4: 0, 5: 0 };
  
  recentTrials.forEach(trial => {
    if (trial.note) {
      const octave = parseInt(trial.note.slice(-1));
      if (octave >= 3 && octave <= 5) {
        distribution[octave]++;
      }
    }
  });
  
  // Convert to proportions
  const total = distribution[3] + distribution[4] + distribution[5];
  if (total > 0) {
    distribution[3] /= total;
    distribution[4] /= total;
    distribution[5] /= total;
  }
  
  return distribution;
}

// A) OOB OCTAVE MIRRORING - Get in-bounds octave mix for current block
function getInBoundsOctaveMixForBlock() {
  // Get current block trials (in-bounds only)
  const currentBlock = blockFromIndex(state.levelIndex);
  const blockTrials = state.trials.filter(t => 
    !t.oob && 
    t.block === currentBlock
  );
  
  const counts = { 3: 0, 4: 0, 5: 0 };
  
  blockTrials.forEach(trial => {
    if (trial.note) {
      const octave = parseInt(trial.note.slice(-1));
      if (octave >= 3 && octave <= 5) {
        counts[octave]++;
      }
    }
  });
  
  // Convert to fractions
  const total = counts[3] + counts[4] + counts[5];
  const fractions = { 3: 0, 4: 0, 5: 0 };
  
  if (total > 0) {
    fractions[3] = counts[3] / total;
    fractions[4] = counts[4] / total;
    fractions[5] = counts[5] / total;
  } else {
    // Default distribution if no data
    fractions[3] = 0.15;
    fractions[4] = 0.7;
    fractions[5] = 0.15;
  }
  
  return fractions;
}

// Select octave for OOB note, mirroring in-bounds distribution
function selectOctaveForOOBNote(note) {
  // FIX 3: Use block-based octave mirroring from frozen snapshot as specified
  // Use the frozen snapshot from beginTimeBlock()
  const frozenMix = state.octaveSnapshotForOOB?.inBoundsMix || {3: 0, 4: 1, 5: 0};
  
  // Respect gating - don't sample octaves that aren't unlocked yet
  const unlockedOctaves = currentOctaves ? currentOctaves() : [3, 4, 5];
  
  // Filter distribution to only unlocked octaves
  let availableDistribution = { 3: 0, 4: 0, 5: 0 };
  let totalAvailable = 0;
  
  unlockedOctaves.forEach(oct => {
    if (oct >= 3 && oct <= 5) {
      availableDistribution[oct] = frozenMix[oct];
      totalAvailable += frozenMix[oct];
    }
  });
  
  // Normalize available distribution
  if (totalAvailable > 0) {
    Object.keys(availableDistribution).forEach(oct => {
      availableDistribution[oct] /= totalAvailable;
    });
  } else {
    // Fallback to equal distribution among unlocked octaves
    unlockedOctaves.forEach(oct => {
      if (oct >= 3 && oct <= 5) {
        availableDistribution[oct] = 1.0 / unlockedOctaves.length;
      }
    });
  }
  
  // Sample according to available proportions
  const rand = Math.random();
  let cumulative = 0;
  for (let oct of [3, 4, 5]) {
    cumulative += availableDistribution[oct];
    if (rand <= cumulative && availableDistribution[oct] > 0) {
      return oct;
    }
  }
  
  // Fallback to first unlocked octave
  return unlockedOctaves[0] || 4;
}

function selectOctaveForNote(note) {
  initializeOctaveState();
  
  const stats = state.octaveStats;
  const octaves = getOctaveRange();
  const centerOctave = stats.centerOctave;
  const neighbors = octaves.filter(o => o !== centerOctave);
  
  // Enforce early distribution: Trials 1-12 = 90% center / 10% neighbors
  const currentSet = setFromIndex(state.levelIndex);
  const setTrials = stats.setTrials.filter(t => t.set === currentSet);
  const trialNum = setTrials.length + 1; // Next trial number
  
  let centerWeight, neighborWeight;
  
  if (trialNum <= 12) {
    // Early distribution: 90% center / 10% neighbors
    centerWeight = 0.90;
    neighborWeight = 0.10;
  } else {
    // Use adaptive mixing based on performance
    const mix = stats.currentMix;
    centerWeight = mix.center;
    neighborWeight = mix.neighbors;
  }
  
  // Check for per-note override (weak notes get more center)
  const noteStats = state.noteStats?.[note];
  let centerBoost = 0;
  if (noteStats && (noteStats.accuracy < 0.75 || noteStats.medianError > 25)) {
    centerBoost = 0.20; // +20% center for weak notes
  }
  
  const finalCenterWeight = Math.min(0.95, centerWeight + centerBoost);
  
  // Select octave based on weights
  const selectedOctave = Math.random() < finalCenterWeight ? centerOctave : rand(neighbors);
  
  return selectedOctave;
}

function updateOctaveMixing(trialData) {
  initializeOctaveState();
  
  const stats = state.octaveStats;
  stats.trialCount++;
  
  // Ensure setTrials array exists (can be missing during simulation)
  if (!stats.setTrials) {
    stats.setTrials = [];
  }
  
  // Initialize QA octave tracking
  if (!state.qa) state.qa = {};
  if (!state.qa.octaves) state.qa.octaves = {
    inBounds: { 3: 0, 4: 0, 5: 0 },
    oob: { 3: 0, 4: 0, 5: 0 },
    mirrorCheck: [],
    lastInBoundsWindow: { 3: 0, 4: 0, 5: 0 }, // For mirror check logic
    inBoundsWindowTrials: [] // Rolling window of last completed in-bounds trials
  };
  
  // Ensure inBoundsWindowTrials array exists
  if (!state.qa.octaves.inBoundsWindowTrials) {
    state.qa.octaves.inBoundsWindowTrials = [];
  }
  
  // Track octave counts for QA export
  const octave = trialData.oct;
  if (octave >= 3 && octave <= 5) {
    if (trialData.oob) {
      state.qa.octaves.oob[octave]++;
    } else {
      state.qa.octaves.inBounds[octave]++;
      
      // Add to windowed tracking for mirror logic
      state.qa.octaves.inBoundsWindowTrials.push({
        octave: octave,
        block: trialData.block,
        timestamp: trialData.time
      });
      
      // Keep only last 40 in-bounds trials for window
      if (state.qa.octaves.inBoundsWindowTrials.length > 40) {
        state.qa.octaves.inBoundsWindowTrials = state.qa.octaves.inBoundsWindowTrials.slice(-40);
      }
    }
  }
  
  // Only count graded in-bounds trials for the original octave mixing logic
  if (!trialData.oob && trialData.set) {
    stats.setTrials.push(trialData);
    
    // Check performance windows at specific trial counts
    const trialNum = stats.setTrials.length;
    
    if (trialNum === 12) {
      checkOctaveStep(8, 12, 'window8_12');
    } else if (trialNum === 16) {
      checkOctaveStep(12, 16, 'window12_16');
    } else if (trialNum === 20) {
      checkOctaveStep(16, 20, 'window16_20');
    } else if (trialNum === 24) {
      checkOctaveStep(20, 24, 'window20_24');
      processEndOfSetPromotion();
      
      // Add mirror check at end of block
      addOctaveMirrorCheck(trialData.block);
    }
  }
  
  save();
}

function checkOctaveStep(startTrial, endTrial, windowKey) {
  const stats = state.octaveStats;
  const windowTrials = stats.setTrials.slice(startTrial - 1, endTrial);
  
  if (windowTrials.length < 4) return; // Need minimum trials
  
  const accuracy = windowTrials.filter(t => t.correct).length / windowTrials.length;
  const errors = windowTrials.map(t => Math.abs(t.jitter?.jitter || 0));
  const medianError = errors.sort((a, b) => a - b)[Math.floor(errors.length / 2)];
  
  // Calculate standard deviation
  const mean = errors.reduce((a, b) => a + b, 0) / errors.length;
  const variance = errors.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / errors.length;
  const stdDev = Math.sqrt(variance);
  
  // Calculate chosen mix for this window
  const centerCount = windowTrials.filter(t => {
    const noteOctave = parseInt(t.note?.slice(-1));
    return noteOctave === stats.centerOctave;
  }).length;
  const chosenMix = {
    center: centerCount / windowTrials.length,
    neighbors: 1 - (centerCount / windowTrials.length)
  };
  
  const windowData = { 
    accuracy: Math.round(accuracy * 100), 
    medianCents: Math.round(medianError * 10) / 10,
    sdCents: Math.round(stdDev * 10) / 10,
    trials: windowTrials.length,
    chosenMix: {
      center: Math.round(chosenMix.center * 100),
      neighbors: Math.round(chosenMix.neighbors * 100)
    },
    windowRange: `${startTrial}-${endTrial}`,
    timestamp: Date.now()
  };
  
  stats.performanceWindows[windowKey] = windowData;
  
  // Log to octaveWindowMetrics
  if (!state.octaveWindowMetrics) state.octaveWindowMetrics = [];
  state.octaveWindowMetrics.push({
    set: setFromIndex(state.levelIndex),
    window: windowKey,
    ...windowData
  });
  
  // Apply stepping rules
  if (windowKey === 'window8_12') {
    if (accuracy >= 0.80 && medianError <= 15) {
      stats.currentMix = { center: 0.70, neighbors: 0.30 };
    } else {
      // Re-check at trial 16
      stats.recheckAt16 = true;
    }
  } else if (windowKey === 'window12_16' && stats.recheckAt16) {
    if (accuracy >= 0.80 && medianError <= 15) {
      stats.currentMix = { center: 0.70, neighbors: 0.30 };
    }
    delete stats.recheckAt16;
  } else if (windowKey === 'window16_20') {
    if (accuracy >= 0.85 && medianError <= 12) {
      stats.currentMix = { center: 0.60, neighbors: 0.40 };
    }
  }
}

function processEndOfSetPromotion() {
  const stats = state.octaveStats;
  const window20_24 = stats.performanceWindows.window20_24;
  
  if (!window20_24) return;
  
  const { accuracy, medianError } = window20_24;
  const errors = stats.setTrials.slice(-4).map(t => Math.abs(t.jitter?.jitter || 0));
  const mean = errors.reduce((a, b) => a + b, 0) / errors.length;
  const variance = errors.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / errors.length;
  const stdDev = Math.sqrt(variance);
  
  // Determine next set baseline
  if (accuracy >= 0.90 && medianError <= 10 && stdDev <= 15) {
    stats.currentMix = { center: 0.50, neighbors: 0.50 }; // 50/50
  } else if (accuracy >= 0.85 && medianError <= 12) {
    stats.currentMix = { center: 0.60, neighbors: 0.40 }; // 60/40
  } else if (accuracy < 0.80) {
    stats.currentMix = { center: 0.90, neighbors: 0.10 }; // Back to 90/10 if struggling
  } else {
    stats.currentMix = { center: 0.70, neighbors: 0.30 }; // Default to 70/30
  }
  
  // Reset for next set
  stats.setTrials = [];
  stats.performanceWindows = {
    window8_12: null,
    window12_16: null,
    window16_20: null,
    window20_24: null
  };
}

// Add octave mirror check at block boundaries using last completed in-bounds window
function addOctaveMirrorCheck(blockIdx) {
  if (!state.qa?.octaves) return;
  
  // Calculate last completed in-bounds window distribution
  const windowTrials = state.qa.octaves.inBoundsWindowTrials || [];
  const lastInBoundsWindow = { 3: 0, 4: 0, 5: 0 };
  
  // Count octaves in the windowed trials
  windowTrials.forEach(trial => {
    if (trial.octave >= 3 && trial.octave <= 5) {
      lastInBoundsWindow[trial.octave]++;
    }
  });
  
  // Store the last completed in-bounds window for OOB selector
  state.qa.octaves.lastInBoundsWindow = { ...lastInBoundsWindow };
  
  const totalInBounds = lastInBoundsWindow[3] + lastInBoundsWindow[4] + lastInBoundsWindow[5];
  const oob = state.qa.octaves.oob;
  const totalOOB = oob[3] + oob[4] + oob[5];
  
  if (totalInBounds === 0) {
    // Empty window - fallback to center-only, don't log as no_inbounds
    state.qa.octaves.mirrorCheck.push({
      blockIdx: blockIdx,
      mirrored: false,
      reason: 'empty_window_fallback',
      timestamp: Date.now()
    });
    return;
  }
  
  if (totalOOB === 0) {
    // No OOB data to compare
    state.qa.octaves.mirrorCheck.push({
      blockIdx: blockIdx,
      mirrored: false,
      reason: 'no_oob',
      timestamp: Date.now()
    });
    return;
  }
  
  // Calculate percentages using windowed in-bounds data
  const inBoundsPct = {
    3: lastInBoundsWindow[3] / totalInBounds,
    4: lastInBoundsWindow[4] / totalInBounds,
    5: lastInBoundsWindow[5] / totalInBounds
  };
  
  const oobPct = {
    3: oob[3] / totalOOB,
    4: oob[4] / totalOOB,
    5: oob[5] / totalOOB
  };
  
  // Check if distributions are similar (within 15% for each octave)
  const threshold = 0.15;
  const mirrored = Math.abs(inBoundsPct[3] - oobPct[3]) <= threshold &&
                   Math.abs(inBoundsPct[4] - oobPct[4]) <= threshold &&
                   Math.abs(inBoundsPct[5] - oobPct[5]) <= threshold;
  
  state.qa.octaves.mirrorCheck.push({
    blockIdx: blockIdx,
    mirrored: mirrored,
    inBoundsPct: {
      3: num(inBoundsPct[3], 0),
      4: num(inBoundsPct[4], 0),
      5: num(inBoundsPct[5], 0)
    },
    oobPct: {
      3: num(oobPct[3], 0),
      4: num(oobPct[4], 0),
      5: num(oobPct[5], 0)
    },
    windowSize: totalInBounds,
    timestamp: Date.now()
  });
  
  // Keep only last 50 entries
  if (state.qa.octaves.mirrorCheck.length > 50) {
    state.qa.octaves.mirrorCheck = state.qa.octaves.mirrorCheck.slice(-50);
  }
}

function currentOctaves(){ 
  // All audio types now use octaves 3-5
  return [3, 4, 5];
}
function rand(a){ return a[Math.floor(Math.random()*a.length)]; }
function pcLabel(pc){ return PC_LABEL[pc] || pc; }

function updateLevelUI(){
  const set=setFromIndex(state.levelIndex), block=blockFromIndex(state.levelIndex);
  textWithTooltip('setInfo', `Pitches ${set} / 12`);
  textWithTooltip('blockInfo', `Block ${block} / 24`);
  if(block >= 21){ textWithTooltip('accInfo', `Testing ‚Äî No Feedback`); }
  else{
    const req=fmtPct(thresholdForIndex(state.levelIndex), 0);
    const acc=fmtPct(state.levelCorrect/state.levelTrials||0, 0);
    textWithTooltip('accInfo', `Acc ${acc} (req ${req})`);
  }
  textWithTooltip('delayInfo', `RT limit: ${rtWindowForSet(set)}ms ‚Ä¢ Delay: ${delayMs}ms`);
  
  // Update jitter and octave status for active sessions
  if (sessionActive && set >= 1) {
    updateJitterStatusUI(set);
    updateOctaveStatusUI();
  } else {
    byId('jitterInfo').style.display = 'none';
    byId('octaveInfo').style.display = 'none';
  }
}

/* Enable/disable guess buttons based on trial state */
function enableGuessButtons(mode) {
  // Get all pitch buttons and OOB button
  const pitchButtons = document.querySelectorAll('[data-guess]');
  const oobButton = document.querySelector('[data-oob]');
  
  if (mode === "off") {
    // Disable ALL guess buttons
    pitchButtons.forEach(btn => btn.disabled = true);
    if (oobButton) oobButton.disabled = true;
  } else if (mode === "inb" || mode === "oob") {
    // Enable ALL pitch buttons and OOB button
    pitchButtons.forEach(btn => btn.disabled = false);
    if (oobButton) oobButton.disabled = false;
  }
}

/* Build note pad and attach handlers */
function paintNotes(){
  const pad=byId('notePad'); if(!pad) return; pad.innerHTML='';
  const set=setFromIndex(state.levelIndex);
  const learned = new Set(trainedSet(set));
  const sorted = PC.filter(pc=> learned.has(pc));
  for(const pc of sorted){
    const b=document.createElement('button');
    b.textContent=pcLabel(pc);
    b.dataset.guess=pc; // Use data-guess as specified
    b.className='note';
    b.type='button';
    pad.appendChild(b);
  }
  safe('btnOOB', el=> {
    el.style.display = set>=12 ? 'none' : 'block';
    el.dataset.oob = "1"; // Use data-oob as specified
  });
}

/* ---------- Specials at BLOCK 15 (weakest from last 15 blocks) ---------- */
function chooseWeakestFromLastBlocks(nBlocks=15){
  const set = setFromIndex(state.levelIndex);
  const curBlock = blockFromIndex(state.levelIndex);
  const from = Math.max(1, curBlock - (nBlocks - 1));
  const trained = new Set(trainedSet(set));
  const windowTrials = (state.trials||[]).filter(t =>
    t.set === set && t.block >= from && t.block <= curBlock && t.block >= 1 && t.block <= 20
  );
  const stats = new Map();
  for(const pc of trained) stats.set(pc, {ok:0, n:0, order:UNLOCK_ORDER.indexOf(pc)});
  for(const t of windowTrials){ if(!trained.has(t.pc)) continue; const s=stats.get(t.pc); s.n++; if(t.correct) s.ok++; }
  let pick=null;
  for(const [pc,s] of stats){
    if(pick===null) pick={pc,...s};
    else if(s.ok < pick.ok || (s.ok===pick.ok && s.n > pick.n) || (s.ok===pick.ok && s.n===pick.n && s.order < pick.order)) pick={pc,...s};
  }
  return pick ? pick.pc : UNLOCK_ORDER[Math.min(set-1, UNLOCK_ORDER.length-1)];
}
function startSpecialAtBlock15(){
  const set = setFromIndex(state.levelIndex);
  if(set < 5) return false;
  if(blockFromIndex(state.levelIndex) !== 15) return false;
  if(state.specialRanForLevel === state.levelIndex) return false;
  state.specialRanForLevel = state.levelIndex; save();

  const targetPc = chooseWeakestFromLastBlocks(15);
  special = {mode:'A', targetPc, total:12, done:0, withFeedback:true, correct:0};
  showSpecialUI(true, `Special A ‚Äî focus: ${pcLabel(targetPc)}`);
  text('btnTarget', `Target (${pcLabel(targetPc)})`);
  text('btnOther',  'Other (¬±2 semitones)');
  nextSpecialTrial(true);
  return true;
}
function showSpecialUI(show, label){
  if(show){
    showFlex('specialBar'); text('specialText', label||'Special Exercise');
    text('specialCount', '0 / 0');
    showBlock('binaryPad'); hide('notePad'); hide('btnOOB');
  }else{
    hide('specialBar'); hide('binaryPad'); showBlock('notePad');
    const set=setFromIndex(state.levelIndex);
    safe('btnOOB', el=> el.style.display = set>=12 ? 'none' : 'block');
  }
}
function nextSpecialTrial(){
  if(!special) return;
  const set=setFromIndex(state.levelIndex);
  const plusMinusTwoPitches = getPlusMinusTwoSemitones(special.targetPc);
  const isTarget = Math.random()<0.5;
  const pitchPc = isTarget ? special.targetPc : rand(plusMinusTwoPitches.filter(p => p !== special.targetPc));
  truePc = pitchPc; isOOBTrial = !isTarget;
  currentNote = `${pitchPc}${rand(currentOctaves())}`;
  playSample(currentNote);
  clearTimeout(rtTimer); rtTimer=null; // no RT in specials
  text('promptPill','Target or Other?');
  text('specialCount', `${special.done} / ${special.total}`);
}
function endSpecialOrAdvance(){
  if(!special) return;
  if(special.done >= special.total){
    if(special.mode==='A'){
      special = {mode:'B', targetPc: special.targetPc, total:22, done:0, withFeedback:false, correct:0};
      showSpecialUI(true, `Special B ‚Äî focus: ${pcLabel(special.targetPc)}`);
      text('btnTarget', `Target (${pcLabel(special.targetPc)})`);
      nextSpecialTrial();
    }else{
      const trials = (state.trials||[]).filter(t=> (t.special==='A' || t.special==='B') && t.pc===special.targetPc);
      const ok = trials.filter(t=> t.correct).length;
      const n  = trials.length;
      const pct = n ? Math.round((ok/n)*1000)/10 : 0;
      alert(`üéâ Hooray! You identified ${pcLabel(special.targetPc)} at ${pct}% accuracy.`);
      special = null; showSpecialUI(false);
      text('promptPill','Specials done ‚Äî press Play to continue');
      /* one-shot suppress strict modal after specials */
      suppressStrictOnce = true;
    }
  }
}
function answerSpecial(userSaysTarget){
  if(!special) return;
  const correct = (userSaysTarget && !isOOBTrial) || (!userSaysTarget && isOOBTrial);
  state.trials.push({note:currentNote, pc:truePc, guess:userSaysTarget?'TARGET':'OTHER', correct, timeout:false, oob:isOOBTrial, set:setFromIndex(state.levelIndex), block:0, time:Date.now(), special:special.mode});
  save();
  if(special.withFeedback){
    feedback(correct, correct ? undefined : (isOOBTrial ? 'Incorrect ‚Äî Out of Bounds' : `Incorrect ‚Äî ${pcLabel(truePc)}`));
  }
  if(correct) special.correct = (special.correct||0) + 1;
  special.done++; text('specialCount', `${special.done} / ${special.total}`);
  if(special.done >= special.total) { endSpecialOrAdvance(); return; }
  setTimeout(()=> nextSpecialTrial(), Math.max(500, delayMs));
}

/* ------------------ ASSESSMENT TEST ------------------ */
function startAssessment() {
  // Show warning modal first
  byId('assessmentWarningModal').style.display = 'flex';
}

function proceedWithAssessment() {
  // Hide warning modal and start assessment
  byId('assessmentWarningModal').style.display = 'none';
  
  showScreen('assessmentScreen');
  assessmentActive = false;
  assessmentTrials = [];
  assessmentCurrentTrial = 0;
  
  text('assessmentProgress', 'Trial 0 / 20');
  text('assessmentPrompt', 'Press Start to begin assessment');
  hide('assessmentResults');
  
  populateAssessmentNotes();
}

function cancelAssessment() {
  byId('assessmentWarningModal').style.display = 'none';
}

function populateAssessmentNotes() {
  const pad = byId('assessmentPad');
  if (!pad) return;
  pad.innerHTML = '';
  
  for (const pc of PC) {
    const b = document.createElement('button');
    b.textContent = pcLabel(pc);
    b.dataset.pc = pc;
    b.className = 'note';
    b.type = 'button';
    b.addEventListener('click', () => assessmentGuess(pc));
    pad.appendChild(b);
  }
}

function beginAssessment() {
  assessmentActive = true;
  assessmentTrials = [];
  assessmentCurrentTrial = 0;
  
  // Generate 20 random trials with random audio types and pitches
  for (let i = 0; i < 20; i++) {
    const audioTypes = [AUDIO_TYPES.PIANO, AUDIO_TYPES.SINE, AUDIO_TYPES.GUITAR];
    const randomAudioType = rand(audioTypes);
    const randomPc = rand(PC);
    
    // Use octaves 3-5 for all audio types
    const octaves = [3, 4, 5];
    const randomOctave = rand(octaves);
    
    assessmentTrials.push({
      pc: randomPc,
      note: `${randomPc}${randomOctave}`,
      audioType: randomAudioType,
      answered: false,
      guess: null,
      correct: false
    });
  }
  
  nextAssessmentTrial();
}

async function nextAssessmentTrial() {
  if (assessmentCurrentTrial >= assessmentTrials.length) {
    completeAssessment();
    return;
  }
  
  const trial = assessmentTrials[assessmentCurrentTrial];
  text('assessmentProgress', `Trial ${assessmentCurrentTrial + 1} / 20`);
  text('assessmentPrompt', 'Listening‚Ä¶ choose the pitch');
  
  // Temporarily change audio type for this trial
  const originalAudioType = state.audioType;
  state.audioType = trial.audioType;
  
  try {
    await playSample(trial.note);
  } finally {
    // Restore original audio type
    state.audioType = originalAudioType;
  }
}

function assessmentGuess(pc) {
  if (!assessmentActive || assessmentCurrentTrial >= assessmentTrials.length) return;
  
  const trial = assessmentTrials[assessmentCurrentTrial];
  if (trial.answered) return;
  
  trial.answered = true;
  trial.guess = pc;
  trial.correct = (pc === trial.pc);
  
  assessmentCurrentTrial++;
  
  // Small delay before next trial
  setTimeout(() => {
    if (assessmentCurrentTrial < assessmentTrials.length) {
      nextAssessmentTrial();
    } else {
      completeAssessment();
    }
  }, 800);
}

function completeAssessment() {
  assessmentActive = false;
  
  let correct = 0;
  let nearMiss = 0; // Within ¬±1 semitone
  
  for (const trial of assessmentTrials) {
    if (trial.correct) {
      correct++;
    } else if (trial.guess) {
      const targetIdx = PC2I[trial.pc];
      const guessIdx = PC2I[trial.guess];
      const distance = Math.min(
        Math.abs(targetIdx - guessIdx),
        12 - Math.abs(targetIdx - guessIdx)
      );
      if (distance <= 1) {
        nearMiss++;
      }
    }
  }
  
  const exactPercent = Math.round((correct / 20) * 100);
  const nearMissPercent = Math.round((nearMiss / 20) * 100);
  
  // Store result
  const result = {
    date: Date.now(),
    exact: exactPercent,
    nearMiss: nearMissPercent,
    trials: assessmentTrials.slice()
  };
  
  state.assessmentScores.push(result);
  save();
  
  // Show results in modal
  const modalStats = byId('modalAssessmentStats');
  if (modalStats) {
    modalStats.innerHTML = `
      <div style="font-size:18px;margin:8px 0">
        <div><strong>Exact Correct: ${exactPercent}%</strong> (${correct}/20)</div>
        <div>Within ¬±1 semitone: ${nearMissPercent}% (${nearMiss}/20)</div>
      </div>
    `;
  }
  
  // Show results modal
  byId('assessmentResultsModal').style.display = 'flex';
  
  // Update chart if possible
  try { drawChart(); } catch(_) {}
}

/* ------------------ ASSESSMENT TRACKER ------------------ */
function showTracker() {
  showScreen('trackerScreen');
  updateTrackerDisplay();
  drawTrackerChart();
}

function updateTrackerDisplay() {
  const scores = state.assessmentScores || [];
  const count = scores.length;
  text('trackerCount', `${count} assessment${count === 1 ? '' : 's'}`);
  
  const history = byId('trackerHistory');
  if (!history) return;
  
  if (count === 0) {
    history.innerHTML = '<p style="opacity:0.7;text-align:center">No assessments completed yet</p>';
    return;
  }
  
  // Sort by date (most recent first)
  const sortedScores = [...scores].sort((a, b) => b.date - a.date);
  
  let html = '';
  sortedScores.forEach((score, index) => {
    const date = new Date(score.date).toLocaleDateString();
    const time = new Date(score.date).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
    html += `
      <div style="padding:8px;margin:4px 0;border-radius:8px;background:var(--muted2);display:flex;justify-content:space-between;align-items:center">
        <div>
          <strong>${date} ${time}</strong>
        </div>
        <div>
          <span style="color:var(--good)">Exact: ${score.exact}%</span> ‚Ä¢ 
          <span style="color:var(--accent)">¬±1: ${score.nearMiss}%</span>
        </div>
      </div>
    `;
  });
  
  history.innerHTML = html;
}

function drawTrackerChart() {
  const canvas = byId('trackerCanvas');
  if (!canvas) return;
  
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  ctx.clearRect(0, 0, W, H);
  
  const P = {l: 56, r: 24, t: 16, b: 28};
  const AX = P.l, AY = P.t, AW = W - P.l - P.r, AH = H - P.t - P.b;
  
  const colCard = getComputedStyle(document.documentElement).getPropertyValue('--card') || '#1e293b';
  const colMuted = getComputedStyle(document.documentElement).getPropertyValue('--muted') || '#334155';
  ctx.fillStyle = colCard;
  ctx.fillRect(0, 0, W, H);
  
  const scores = state.assessmentScores || [];
  if (scores.length === 0) {
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text') || '#e5e7eb';
    ctx.font = '14px Fredoka, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('No assessment data yet', W / 2, H / 2);
    return;
  }
  
  // Sort by date
  const sortedScores = [...scores].sort((a, b) => a.date - b.date);
  
  const maxTests = Math.max(10, sortedScores.length);
  const xScale = (i) => AX + (i / (maxTests - 1)) * AW;
  const yScale = (pct) => AY + AH - (pct / 100) * AH;
  
  // Draw grid lines
  ctx.strokeStyle = colMuted;
  ctx.lineWidth = 1;
  for (let i = 0; i <= 100; i += 20) {
    const y = yScale(i);
    ctx.beginPath();
    ctx.moveTo(AX, y);
    ctx.lineTo(AX + AW, y);
    ctx.stroke();
  }
  
  // Draw axes
  ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--muted') || '#334155';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(AX, AY);
  ctx.lineTo(AX, AY + AH);
  ctx.lineTo(AX + AW, AY + AH);
  ctx.stroke();
  
  // Draw Y-axis labels
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text') || '#e5e7eb';
  ctx.font = '12px Fredoka, sans-serif';
  ctx.textAlign = 'right';
  for (let i = 0; i <= 100; i += 20) {
    ctx.fillText(`${i}%`, AX - 8, yScale(i) + 4);
  }
  
  if (sortedScores.length > 1) {
    // Draw exact scores line
    const exactColor = getComputedStyle(document.documentElement).getPropertyValue('--good') || '#16a34a';
    ctx.beginPath();
    ctx.strokeStyle = exactColor;
    ctx.lineWidth = 3;
    sortedScores.forEach((score, i) => {
      const x = xScale(i);
      const y = yScale(score.exact);
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    });
    ctx.stroke();
    
    // Draw near-miss scores line
    const nearMissColor = getComputedStyle(document.documentElement).getPropertyValue('--accent') || '#fbbf24';
    ctx.beginPath();
    ctx.strokeStyle = nearMissColor;
    ctx.lineWidth = 3;
    sortedScores.forEach((score, i) => {
      const x = xScale(i);
      const y = yScale(score.nearMiss);
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    });
    ctx.stroke();
  }
  
  // Draw data points
  sortedScores.forEach((score, i) => {
    const x = xScale(i);
    
    // Exact score point
    ctx.beginPath();
    ctx.arc(x, yScale(score.exact), 4, 0, Math.PI * 2);
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--good') || '#16a34a';
    ctx.fill();
    
    // Near-miss score point
    ctx.beginPath();
    ctx.arc(x, yScale(score.nearMiss), 4, 0, Math.PI * 2);
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent') || '#fbbf24';
    ctx.fill();
  });
}

/* -------- Normal trials -------- */
function guess(pc){
  if(!sessionActive || paused || special) return;
  if(!state.awaitingInput) return; // Check input gating
  if(!currentNote){ return; }
  
  // Immediately disable buttons and clear awaiting input state
  state.awaitingInput = false;
  enableGuessButtons("off");
  
  try {
    if(rtTimer){ clearTimeout(rtTimer); rtTimer=null; }
    const ok = (!isOOBTrial && pc === truePc);
    const rtMs = Math.round(performance.now() - (trialStartTime || performance.now()));
    
    // Record to QA arrays as specified in problem statement
    qa.trials.push({
      trueNote: currentNote,
      truePc: truePc,
      guess: ok ? currentNote : `${pc}${currentNote ? currentNote.slice(-1) : '4'}`,
      guessPc: pc,
      correct: ok,
      oob: false,
      rtMs: rtMs
    });
    
    recordTrial(pc, ok, false, false);
    feedback(ok, ok ? undefined : (isOOBTrial ? 'Incorrect ‚Äî Out of Bounds' : `Incorrect ‚Äî ${pcLabel(truePc)}`));
    currentNote = null; // Clear currentNote to prevent repeated guesses
    advanceCheck();
    scheduleAuto();
  } finally {
    // Ensure buttons remain disabled even if something throws
  }
}
function chooseOOB(){
  if(!sessionActive || paused || special) return;
  if(!state.awaitingInput) return; // Check input gating
  if(!currentNote) return;
  
  // Immediately disable buttons and clear awaiting input state
  state.awaitingInput = false;
  enableGuessButtons("off");
  
  try {
    if(rtTimer){ clearTimeout(rtTimer); rtTimer=null; }
    const ok = isOOBTrial;
    const rtMs = Math.round(performance.now() - (trialStartTime || performance.now()));
    
    // Record to QA arrays as specified in problem statement
    qa.trials.push({
      trueNote: currentNote,
      truePc: truePc,
      guess: null,
      guessPc: null,
      correct: ok,
      oob: true,
      rtMs: rtMs
    });
    
    recordTrial('OOB', ok, false, true);
    const msg = ok ? undefined : `Incorrect ‚Äî ${pcLabel(truePc)}`;
    feedback(ok, msg);
    currentNote = null; // Clear currentNote to prevent repeated guesses
    advanceCheck();
    scheduleAuto();
  } finally {
    // Ensure buttons remain disabled even if something throws
  }
}

/* Driving */
function scheduleAuto(){ if(autoTimer){ clearTimeout(autoTimer); autoTimer=null; } if(autoNext && sessionActive && !paused && !special){ autoTimer = setTimeout(()=> nextTrial(true), delayMs); } }
async function nextTrial(forceNew=false){
  if(!sessionActive || paused || special) return;
  if(inFlightTrial) return;

  /* clear the one-shot strict suppression as soon as normal play resumes */
  suppressStrictOnce = false;

  if(startSpecialAtBlock15()) return;

  inFlightTrial=true;
  trialStartTime = performance.now(); // Track trial start time for RT measurement
  try{
    await resumeCtx();
    if(paused || !sessionActive || special) return;
    if(!currentNote || forceNew){
      const set = setFromIndex(state.levelIndex);
      const usable = trainedSet(set);
      
      // Use enhanced OOB system
      isOOBTrial = shouldGenerateOOB(set);
      
      if (isOOBTrial) {
        const pc = selectOOBNote(set);
        truePc = pc;
      } else {
        // Apply confusion-aware scheduling for in-bounds
        const pc = selectInBoundsNote(usable);
        truePc = pc;
      }
      
      currentNote = `${truePc}${isOOBTrial ? selectOctaveForOOBNote(truePc) : selectOctaveForNote(truePc)}`;
    }
    
    // Apply jitter system for in-bounds trials only
    if (!isOOBTrial) {
      // Initialize jitter level for this note if needed
      initializeJitterLevel(truePc);
      
      // Get jitter info using new system
      currentTrialJitter = getJitterInfo(truePc);
    } else {
      // OOB trials have no jitter (0¬¢ detune, stationary)
      currentTrialJitter = {
        jitter: 0,
        isProbe: false,
        isAnchor: false,
        level: null
      };
    }
    
    await playSample(currentNote, currentTrialJitter.jitter);
    
    // FIX 1: Record tone presentation as specified in problem statement
    const toneRecord = {
      note: currentNote,
      pc: truePc,
      oct: currentNote ? parseInt(currentNote.slice(-1)) : null,
      cents: isOOBTrial ? 0 : num(currentTrialJitter.jitter || 0, null),
      detuneMode: isOOBTrial ? "oob" : 
                 (currentTrialJitter.isAnchor ? "anchor" :
                  currentTrialJitter.isProbe ? "probe" : "jitter"),
      isOOB: isOOBTrial,
      timbre: state.audioType || "piano"
    };
    state.tones.push(toneRecord);
    
    // Also record to QA array as specified in problem statement
    qa.tones.push(toneRecord);
    
    // Set up input gating and enable buttons as specified
    state.awaitingInput = true;
    if (isOOBTrial) {
      enableGuessButtons("oob");
    } else {
      enableGuessButtons("inb");
    }
    
    if(rtTimer){ clearTimeout(rtTimer); rtTimer=null; }
    const baseRt = rtWindowForSet(setFromIndex(state.levelIndex));
    const rtms = baseRt + firstRtBonusMs + LATENCY_CUSHION_MS;
    firstRtBonusMs = 0;
    rtTimer = setTimeout(()=>handleTimeout(), rtms);
    text('promptPill','Listening‚Ä¶ choose the pitch');
  }catch(e){ report(e); }
  finally{ inFlightTrial=false; }
}
function handleTimeout(){
  if(!sessionActive || paused || special) return;
  if(rtTimer){ clearTimeout(rtTimer); rtTimer=null; }
  
  // Disable buttons and clear awaiting input state on timeout
  state.awaitingInput = false;
  enableGuessButtons("off");
  
  // Record timeout trial to QA arrays
  qa.trials.push({
    trueNote: currentNote,
    truePc: truePc,
    guess: null,
    guessPc: null,
    correct: false,
    oob: !!isOOBTrial,
    rtMs: null
  });
  
  recordTrial(null,false,true);
  feedback(false, isOOBTrial ? 'Incorrect ‚Äî Out of Bounds' : `Incorrect ‚Äî ${pcLabel(truePc)}`);
  advanceCheck(); scheduleAuto();
}

/* Suggestion banner */
function hideSuggestBanner(){ hide('suggestBanner'); }
function showSuggestBanner(){ const set = setFromIndex(state.levelIndex); if(state.suggestShownSet === set) return; byId('suggestBanner').style.display='flex'; }
function restartCurrentSet(){
  const set = setFromIndex(state.levelIndex);
  state.levelIndex = (set-1)*LEVELS_PER_SET + 1;
  state.levelTrials = 0; state.levelCorrect = 0;
  state.testFailStreak = 0;
  state.suggestShownSet = null; save();
  updateLevelUI(); paintNotes();
  text('promptPill', `Restarted Set ${set}. Press Play to begin.`);
  hideSuggestBanner();
}
function maybeSuggestRestart(){
  const block = blockFromIndex(state.levelIndex);
  if(block < 21){ state.testFailStreak = 0; hideSuggestBanner(); suggestedRestartFlag=false; save(); return; }
  if(state.testFailStreak >= 10 && !suggestedRestartFlag){ suggestedRestartFlag = true; showSuggestBanner(); }
}

// Update running totals for detune types and per-pitch JL stats
function updateDetuneShares(trialData) {
  // Initialize detune shares tracking (legacy)
  if (!state.detune) state.detune = {};
  if (!state.detune.shares) {
    state.detune.shares = {
      anchor: 0,
      jitter: 0, 
      probe: 0,
      oob: 0
    };
  }
  
  // Initialize qa.detune tracking as specified in problem statement
  if (!state.qa.detune.shares.counts) {
    state.qa.detune.shares.counts = { anchors: 0, probes: 0, jitter: 0, total: 0 };
  }
  
  // Update detune type counts for both legacy and qa structures
  const detuneType = trialData.detuneMode;
  if (detuneType && state.detune.shares.hasOwnProperty(detuneType)) {
    state.detune.shares[detuneType]++;
  }
  
  // Update qa.detune.shares counts (skip OOB trials for qa tracking)
  if (!trialData.oob) {
    if (detuneType === 'anchor') {
      state.qa.detune.shares.counts.anchors++;
    } else if (detuneType === 'probe') {
      state.qa.detune.shares.counts.probes++;
    } else if (detuneType === 'jitter') {
      state.qa.detune.shares.counts.jitter++;
    }
    state.qa.detune.shares.counts.total++;
    
    // Update percentages
    const total = state.qa.detune.shares.counts.total;
    if (total > 0) {
      state.qa.detune.shares.pct = {
        anchorsPct: num(state.qa.detune.shares.counts.anchors / total, 0),
        probesPct: num(state.qa.detune.shares.counts.probes / total, 0),
        jitterPct: num(state.qa.detune.shares.counts.jitter / total, 0)
      };
    }
  }
  
  // Initialize per-pitch JL stats if needed
  if (!state.jitter) state.jitter = {};
  if (!state.jitter.perPitch) state.jitter.perPitch = {};
  if (!state.jitter.levels) state.jitter.levels = {};
  
  // Update per-pitch stats for in-bounds trials
  const pc = trialData.pc;
  if (!trialData.oob && pc) {
    // Persist current JL level in jitter.levels[pc]
    state.jitter.levels[pc] = state.jitterLevels?.[pc] ?? 0;
    state.qa.jitter.levels[pc] = state.jitterLevels?.[pc] ?? 0;
    
    if (!state.jitter.perPitch[pc]) {
      state.jitter.perPitch[pc] = {
        JL: trialData.jl || 0,
        lastNTrials: [],
        accuracy: 0,
        medianCents: 0,
        sdCents: 0
      };
    }
    
    // Initialize qa.detune.byPitch if needed
    if (!state.qa.detune.byPitch[pc]) {
      state.qa.detune.byPitch[pc] = {
        JL: 0,
        anchorsPct: 0,
        probesPct: 0,
        jitterPct: 0,
        meanAbsCents: 0,
        medianAbsCents: 0,
        sdAbsCents: 0,
        windowN: 0
      };
    }
    
    // Update JL level from current state
    state.jitter.perPitch[pc].JL = state.jitterLevels?.[pc] ?? 0;
    state.qa.detune.byPitch[pc].JL = state.jitterLevels?.[pc] ?? 0;
    
    // Update rolling window (keep last 40 trials)
    const centsError = Math.abs(trialData.cents || 0);
    state.jitter.perPitch[pc].lastNTrials.push({
      correct: trialData.correct,
      centsError: centsError,
      timestamp: trialData.time
    });
    
    if (state.jitter.perPitch[pc].lastNTrials.length > 40) {
      state.jitter.perPitch[pc].lastNTrials = state.jitter.perPitch[pc].lastNTrials.slice(-40);
    }
    
    // Recalculate rolling stats
    const trials = state.jitter.perPitch[pc].lastNTrials;
    if (trials.length > 0) {
      state.jitter.perPitch[pc].accuracy = trials.filter(t => t.correct).length / trials.length;
      
      const errors = trials.map(t => t.centsError).sort((a, b) => a - b);
      state.jitter.perPitch[pc].medianCents = errors[Math.floor(errors.length / 2)] || 0;
      
      const mean = errors.reduce((a, b) => a + b, 0) / errors.length;
      const variance = errors.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / errors.length;
      state.jitter.perPitch[pc].sdCents = Math.sqrt(variance);
      
      // Update qa.detune.byPitch statistics
      const detuneModeTrials = trials.map((trial, i) => ({
        ...trial,
        mode: trialData.detuneMode // This is simplified - in reality would need to track mode per trial
      }));
      
      const anchorsCount = detuneModeTrials.filter(t => t.mode === 'anchor').length;
      const probesCount = detuneModeTrials.filter(t => t.mode === 'probe').length; 
      const jitterCount = detuneModeTrials.filter(t => t.mode === 'jitter').length;
      const totalCount = anchorsCount + probesCount + jitterCount;
      
      state.qa.detune.byPitch[pc] = {
        JL: state.jitterLevels?.[pc] ?? 0,
        anchorsPct: totalCount > 0 ? num(anchorsCount / totalCount, 0) : 0,
        probesPct: totalCount > 0 ? num(probesCount / totalCount, 0) : 0,
        jitterPct: totalCount > 0 ? num(jitterCount / totalCount, 0) : 0,
        meanAbsCents: num(mean, null),
        medianAbsCents: num(state.jitter.perPitch[pc].medianCents, null),
        sdAbsCents: num(state.jitter.perPitch[pc].sdCents, null),
        windowN: trials.length
      };
    }
  }
}

function recordTrial(guessLabel, ok, timeout=false, oobChosen=false){
  state.levelTrials++; if(ok) state.levelCorrect++;
  const block = blockFromIndex(state.levelIndex);
  if(block >= 21){ if(ok){ state.testFailStreak=0; hideSuggestBanner(); suggestedRestartFlag=false; } else { state.testFailStreak=(state.testFailStreak||0)+1; } }
  else { state.testFailStreak=0; hideSuggestBanner(); suggestedRestartFlag=false; }
  
  // Update centralized counters as specified in problem statement
  state.counters.trialIndex++; // Increment for all trials
  const isGradedInBounds = !isOOBTrial && !timeout; // Only graded in-bounds trials count
  if (isGradedInBounds) {
    state.counters.inbTrialIndex++;
    state.counters.qBlockIndex = Math.floor(state.counters.inbTrialIndex / 20) + 1;
  }
  
  // Update backward compatibility counters
  state.trialIndex = state.counters.trialIndex;
  state.inbTrialIndex = state.counters.inbTrialIndex;
  state.qBlockIndex = state.counters.qBlockIndex;
  
  // B) BOUNDARY PROBE RATE - Enhanced trial data with required fields
  const trialData = {
    note: currentNote,
    pc: truePc,
    oct: currentNote ? parseInt(currentNote.slice(-1)) : null,
    cents: !isOOBTrial && currentTrialJitter ? num(currentTrialJitter.jitter || 0, null) : (isOOBTrial ? 0 : null),
    detuneMode: isOOBTrial ? "oob" : 
               (!currentTrialJitter ? "anchor" :
                currentTrialJitter.isAnchor ? "anchor" :
                currentTrialJitter.isProbe ? "probe" : "jitter"),
    jl: !isOOBTrial && truePc ? (state.jitterLevels?.[truePc] ?? 0) : null, // JL level for this pitch (0-3)
    isOOB: isOOBTrial,
    truePc: truePc,
    guessPc: oobChosen ? null : (guessLabel === 'TARGET' ? truePc : guessLabel),
    guess: guessLabel,
    correct: ok,
    timeout,
    oob: oobChosen,
    set: setFromIndex(state.levelIndex),
    block: block,
    time: Date.now(),
    rtMs: num(timeout ? null : Math.round(performance.now() - (trialStartTime || performance.now())), Date.now()-(state.toneStartMs||Date.now())),
    jitter: currentTrialJitter,
    actualTimbre: currentTrialTimbre, // Store which timbre was actually used
    // Legacy fields for compatibility
    detuneCents: !isOOBTrial && currentTrialJitter ? currentTrialJitter.jitter : (isOOBTrial ? 0 : null)
  };
  
  // Ensure trial object always has safe fields as specified in problem statement
  const normalizedTrial = {
    trueNote: trialData.note || (state.currentPc ? state.currentPc + (state.currentOct ?? 4) : null),
    truePc: trialData.pc || state.currentPc || null,
    guess: trialData.guess ?? null,
    guessPc: trialData.guessPc ?? null,
    correct: !!trialData.correct,
    oob: !!trialData.oob,
    rtMs: num(trialData.rtMs, null),
    ...trialData // Spread the rest of the original data
  };
  
  state.trials.push(normalizedTrial);
  
  // Store detune information for in-bounds trials as specified
  if (!isOOBTrial && currentTrialJitter) {
    const jitterInfo = getJitterInfo(truePc);
    trialData.detune = {
      mode: jitterInfo.mode,
      cents: jitterInfo.cents,
      jl: jitterInfo.level
    };
  }
  
  // Update octave statistics per glossary (FIX 3)
  if (trialData.oct && (trialData.oct === 3 || trialData.oct === 4 || trialData.oct === 5)) {
    if (isOOBTrial) {
      state.octaveStats.oob[trialData.oct]++;
      state.qa.octaves.oob[trialData.oct]++; // FIX 3: Update QA tracking
    } else {
      state.octaveStats.inBounds[trialData.oct]++;
      state.qa.octaves.inBounds[trialData.oct]++; // FIX 3: Update QA tracking
    }
  }
  
  // Update detune type running totals
  updateDetuneShares(trialData);
  
  // Update note statistics for in-bounds trials
  if (!isOOBTrial && truePc) {
    const centsError = currentTrialJitter ? currentTrialJitter.jitter : 0;
    updateNoteStats(truePc, ok, centsError);
    
    // Update timbre-specific statistics
    if (currentTrialTimbre) {
      updateTimbreStats(currentTrialTimbre, truePc, ok, centsError);
    }
    
    // Update confusion matrix if incorrect
    if (!ok && guessLabel !== 'OOB' && guessLabel !== truePc) {
      updateConfusionMatrix(truePc, guessLabel);
    }
    
    // Check for jitter level changes after each graded in-bounds trial
    checkJitterPromotion(truePc);
    checkJitterDemotion(truePc);
  }
  
  // Record OOB trial data for adaptive system
  recordOOBTrial(isOOBTrial, ok);
  
  // Update octave mixing performance
  updateOctaveMixing(trialData);
  
  // Validate OOB state
  validateOOBState();
  
  save(); updateLevelUI(); try{ drawChart(); }catch(_){}; 
  if(block >= 21 && !ok) maybeSuggestRestart();
}

function feedback(ok, wrongMsgOverride){
  const fb=blockHasFeedback(blockFromIndex(state.levelIndex));
  if(!fb && !special?.withFeedback) return;
  const box=byId('feedbackBox'); const overlay=byId('feedbackOverlay');
  if(!box||!overlay) return;
  box.style.background= ok? 'var(--good)':'var(--bad)';
  if(ok) box.textContent = 'Correct!';
  else   box.textContent = wrongMsgOverride || 'Incorrect';
  overlay.style.display='flex'; requestAnimationFrame(()=>overlay.classList.add('show'));
  setTimeout(()=>{ overlay.classList.remove('show'); overlay.style.display='none'; }, 500);
}

function advanceCheck(){
  if(state.levelTrials<20) return;
  const acc=state.levelCorrect/state.levelTrials, need=thresholdForIndex(state.levelIndex);
  const passed = acc>=need;
  const block = blockFromIndex(state.levelIndex);
  const key = String(state.levelIndex);
  
  // Show feedback for test blocks (21-24) at completion
  if(block >= 21) {
    const percentage = Math.round(acc * 100);
    if(passed) {
      alert(`Well done, you passed with ${percentage}%!`);
    } else {
      // Suppress strict modal during failure dialogs
      suppressStrictOnce = true;
      alert(`Sorry you didn't make it with ${percentage}%.`);
      
      // Check for 10-fail streak and show struggle suggestion
      if(state.testFailStreak >= 10) {
        const confirmed = confirm(`Struggling? Perhaps go back to the start of set?\n\nClick OK to restart the set, or Cancel to dismiss and try again.`);
        if(confirmed) {
          restartCurrentSet();
          return;
        }
      }
      // Keep suppression active after dialogs
      suppressStrictOnce = true;
    }
  }
  
  if(!passed){
    state.levelFailCounts[key] = (state.levelFailCounts[key]||0) + 1;
    if(state.levelFailCounts[key] >= 10){
      if(confirm('You‚Äôve attempted this level 10+ times without passing. Drop to a lower level?')){
        if(state.levelIndex>1) state.levelIndex--;
        state.levelTrials=0; state.levelCorrect=0;
        save(); updateLevelUI(); paintNotes();
        alert('Dropped one level. Keep going!');
        return;
      }
    }
  }else{
    state.levelFailCounts[key]=0;
  }
  state.levelTrials=0; state.levelCorrect=0;
  
  // Track completed 6-minute block and handle time-block transitions
  if(passed) {
    endTimeBlock();
  }

  if(passed && state.levelIndex<LEVELS_TOTAL){
    const oldSet = setFromIndex(state.levelIndex);
    state.levelIndex++;
    const newSet = setFromIndex(state.levelIndex);
    save(); updateLevelUI(); paintNotes();
    
    // Check if we're moving to a new set (new pitch introduced)
    if(newSet > oldSet && newSet <= UNLOCK_ORDER.length){
      showNewPitchModal(newSet);
    }
  } else save();
}

/* ------------------ TIME-BLOCK MANAGEMENT ------------------ */
function beginTimeBlock() {
  // Called when a new 6-minute block starts
  // Freeze a snapshot of octave mix for OOB generation during this block
  
  // Calculate in-bounds octave mix from recent trials
  const recentInBounds = state.trials.filter(t => !t.oob && t.correct !== undefined);
  const octaveCounts = {3: 0, 4: 0, 5: 0};
  
  // Use last 60 in-bounds trials, or all if less than 60
  const relevantTrials = recentInBounds.slice(-60);
  
  relevantTrials.forEach(trial => {
    if (trial.oct && octaveCounts[trial.oct] !== undefined) {
      octaveCounts[trial.oct]++;
    }
  });
  
  const total = octaveCounts[3] + octaveCounts[4] + octaveCounts[5];
  
  if (total === 0) {
    // No in-bounds history yet, set to center only as specified
    state.octaveSnapshotForOOB = {
      inBoundsMix: {3: 0, 4: 1, 5: 0},
      available: ["3", "4", "5"]
    };
  } else {
    // Calculate fractions for OOB generation
    state.octaveSnapshotForOOB = {
      inBoundsMix: {
        3: octaveCounts[3] / total,
        4: octaveCounts[4] / total,
        5: octaveCounts[5] / total
      },
      available: ["3", "4", "5"]
    };
  }
  
  save();
}

function endTimeBlock() {
  // Update time-block counters per glossary using centralized counters
  state.minutesToday += BLOCK_LEN_MIN;
  state.counters.globalTimeBlockIndex++;
  state.counters.timeBlockIndex = Math.min(5, Math.floor(((state.minutesToday - BLOCK_LEN_MIN) % 30) / 6) + 1); // 1-5 within day
  
  // Update backward compatibility fields
  state.globalTimeBlockIndex = state.counters.globalTimeBlockIndex;
  state.timeBlockIndex = state.counters.timeBlockIndex;
  
  // Compute OOB octave mirroring at Time-Block START from last completed in-bounds window
  computeOOBOctaveMirroring();
  
  // adaptOOBTarget() ONLY in endTimeBlock(), and only when specified conditions met
  const shouldAdapt = (state.counters.globalTimeBlockIndex % 3 === 0) || 
                      (state.counters.inbTrialIndex - state.counters.lastOOBAdaptAt.inbTrialIndex >= 60);
  
  if (shouldAdapt) {
    adaptOOBTarget();
    state.counters.lastOOBAdaptAt.inbTrialIndex = state.counters.inbTrialIndex;
    state.counters.lastOOBAdaptAt.globalTimeBlockIndex = state.counters.globalTimeBlockIndex;
  }
  
  // Reset OOB streak at block boundary
  state.oobStats.streakCount = 0;
  
  // Update health check block countdown
  if (state.oobStats.healthCheckActive && state.oobStats.healthCheckBlocks > 0) {
    state.oobStats.healthCheckBlocks--;
    if (state.oobStats.healthCheckBlocks <= 0) {
      state.oobStats.healthCheckActive = false;
    }
  }
  
  save();
}

function computeOOBOctaveMirroring() {
  // At endTimeBlock(), write one mirror check row as specified in problem statement
  
  // Get trials from current time block (approximate - could be refined with better time tracking)
  const currentBlockTrials = state.trials.filter(t => {
    return t.time && t.time > (Date.now() - BLOCK_LEN_MIN * 60 * 1000);
  });
  
  // Calculate in-bounds and OOB octave counts for this block
  const inBoundsTrials = currentBlockTrials.filter(t => !t.oob);
  const oobTrials = currentBlockTrials.filter(t => t.oob);
  
  const inBoundsCounts = {3: 0, 4: 0, 5: 0};
  const oobCounts = {3: 0, 4: 0, 5: 0};
  
  inBoundsTrials.forEach(trial => {
    if (trial.oct && inBoundsCounts[trial.oct] !== undefined) {
      inBoundsCounts[trial.oct]++;
    }
  });
  
  oobTrials.forEach(trial => {
    if (trial.oct && oobCounts[trial.oct] !== undefined) {
      oobCounts[trial.oct]++;
    }
  });
  
  // Calculate fractions
  const inBoundsTotal = inBoundsCounts[3] + inBoundsCounts[4] + inBoundsCounts[5];
  const oobTotal = oobCounts[3] + oobCounts[4] + oobCounts[5];
  
  const inBoundsFrac = {
    3: inBoundsTotal > 0 ? inBoundsCounts[3] / inBoundsTotal : 0,
    4: inBoundsTotal > 0 ? inBoundsCounts[4] / inBoundsTotal : 0,
    5: inBoundsTotal > 0 ? inBoundsCounts[5] / inBoundsTotal : 0
  };
  
  const oobFrac = {
    3: oobTotal > 0 ? oobCounts[3] / oobTotal : 0,
    4: oobTotal > 0 ? oobCounts[4] / oobTotal : 0,
    5: oobTotal > 0 ? oobCounts[5] / oobTotal : 0
  };
  
  // Calculate percentage point differences
  const diff_pp = {
    3: (oobFrac[3] - inBoundsFrac[3]) * 100,
    4: (oobFrac[4] - inBoundsFrac[4]) * 100,
    5: (oobFrac[5] - inBoundsFrac[5]) * 100
  };
  
  // Store mirror check row as specified
  state.qa.octaves.mirror.push({
    globalTimeBlockIndex: state.globalTimeBlockIndex,
    inBounds: {3: inBoundsCounts[3], 4: inBoundsCounts[4], 5: inBoundsCounts[5]},
    oob: {3: oobCounts[3], 4: oobCounts[4], 5: oobCounts[5]},
    diff_pp: {
      3: num(diff_pp[3], null),
      4: num(diff_pp[4], null),
      5: num(diff_pp[5], null)
    }
  });
  
  // Also store legacy format for existing code
  const last60InBounds = state.trials.filter(t => !t.oob && t.correct !== undefined).slice(-60);
  if (last60InBounds.length > 0) {
    const octaveCounts = { 3: 0, 4: 0, 5: 0 };
    last60InBounds.forEach(trial => {
      if (trial.oct && octaveCounts[trial.oct] !== undefined) {
        octaveCounts[trial.oct]++;
      }
    });
    
    const total = octaveCounts[3] + octaveCounts[4] + octaveCounts[5];
    if (total > 0) {
      const oct3Pct = (octaveCounts[3] / total) * 100;
      const oct4Pct = (octaveCounts[4] / total) * 100;
      const oct5Pct = (octaveCounts[5] / total) * 100;
      
      const evenPct = 100 / 3;
      const mirrorDiff = Math.max(
        Math.abs(oct3Pct - evenPct),
        Math.abs(oct4Pct - evenPct),
        Math.abs(oct5Pct - evenPct)
      );
      
      state.mirrorDiffPerBlock.push({
        globalTimeBlockIndex: state.globalTimeBlockIndex,
        mirrorDiff_pp: num(mirrorDiff, null),
        octaveDistribution: { 3: oct3Pct, 4: oct4Pct, 5: oct5Pct }
      });
    }
  }
}

/* ------------------ SESSION ------------------ */
function startSession(){
  stopAllTimers();
  sealDanglingSession();
  if(isLocked()){
    const left = state.lockoutUntil - Date.now();
    alert(`Training is locked for ${fmtHMM(left)}.\nYou can still play Flappy from the menu, or Reset lockout/timer.`);
    showScreen('menuScreen'); return;
  }
  
  // Check if we need to do cold recall first
  const today = todayKey(Date.now());
  const lastColdRecall = state.recallResults
    .filter(r => r.type === 'cold')
    .map(r => todayKey(r.date))
    .pop();
  
  if (!lastColdRecall || lastColdRecall < today) {
    // Need to do cold recall first
    state.coldRecallDone = false;
    state.warmRecallDone = false;
    save();
    startRecallTest('cold');
    return;
  }
  
  // Go directly to training
  startTrainingDirectly();
}

function startTrainingDirectly(){
  // Start the training session directly
  sessionActive = true;
  paused = false;
  
  // Create new session record
  const sessionRecord = {
    start: Date.now(),
    end: null,
    pauses: []
  };
  
  state.sessions = state.sessions || [];
  state.sessions.push(sessionRecord);
  
  // Set up break timing
  state.sessionBreakTime = Date.now() + BREAK_INTERVAL_MS;
  state.inBreak = false;
  
  // Initialize new time block at session start
  beginTimeBlock();
  
  save();
  
  // Show trainer screen and start
  showScreen('trainerScreen');
  updateLevelUI();
  initializeTooltips();
  paintNotes();
  text('promptPill', 'Session started ‚Äî press Play to begin training');
  
  // Start session timer that checks for breaks and cap
  startSessionTimer();
}

function startSessionTimer(){
  if(tickId) clearInterval(tickId);
  
  tickId = setInterval(() => {
    if(!sessionActive || paused) return;
    
    const now = Date.now();
    const usedMs = msUsedQuota();
    
    // Check if we've hit the daily cap
    if(usedMs >= SESS_DAILY_MS) {
      clearInterval(tickId);
      tickId = null;
      
      // Set lockout until next calendar day
      state.lockoutUntil = nextMidnight(now);
      save();
      
      endSession(true);
      return;
    }
    
    // Check if we need a mandatory break
    if(!state.inBreak && now >= state.sessionBreakTime) {
      triggerMandatoryBreak();
      return;
    }
    
    // Update timer display
    const left = Math.max(0, SESS_DAILY_MS - usedMs);
    textWithTooltip('timerInfo', `Time left: ${fmtMMSS(left)}`);
    
    // Update training chunk display
    if(!state.inBreak) {
      const chunkUsedMs = usedMs % BREAK_INTERVAL_MS;
      const chunkLeft = Math.max(0, BREAK_INTERVAL_MS - chunkUsedMs);
      const currentChunk = Math.floor(usedMs / BREAK_INTERVAL_MS) + 1;
      const totalChunks = Math.ceil(SESS_DAILY_MS / BREAK_INTERVAL_MS);
      textWithTooltip('chunkInfo', `Training: ${fmtMMSS(chunkLeft)} (${currentChunk}/${totalChunks})`);
    }
    
  }, 1000); // Update every second
}

function endSession(auto){
  if(!sessionActive) return;
  sessionActive=false;
  stopAllTimers();
  
  // Clear trial state
  currentNote = null;
  currentTrialJitter = null;
  currentTrialTimbre = null;
  
  const rec=state.sessions[state.sessions.length-1]; if(rec && !rec.end) rec.end=Date.now();
  save(); updateCapsUI(); try{ drawChart(); }catch(_){};
  
  if(auto){
    // Session completed naturally (30 minutes reached)
    if(!state.warmRecallDone) {
      // Trigger warm recall test
      startRecallTest('warm');
      return;
    } else {
      const left = state.lockoutUntil ? fmtHMM(state.lockoutUntil - Date.now()) : 'some time';
      alert(`Training session complete! Come back tomorrow for your next session.`);
      showScreen('menuScreen');
    }
  } else {
    // Manual session end
    showScreen('menuScreen');
  }
}
function pauseStart(reason){
  const rec=state.sessions[state.sessions.length-1]; if(!rec) return;
  rec.pauses=rec.pauses||[]; const last=rec.pauses[rec.pauses.length-1];
  if(!(last && !last.end)) rec.pauses.push({start:Date.now(), end:null, reason});
  paused=true;
  if(rtTimer){ clearTimeout(rtTimer); rtTimer=null; }
  if(autoTimer){ clearTimeout(autoTimer); autoTimer=null; }
  
  // Stop session timer when paused
  if(tickId){ clearInterval(tickId); tickId=null; }
}
function pauseEnd(){
  const rec=state.sessions[state.sessions.length-1]; if(!rec||!rec.pauses||!rec.pauses.length) return;
  const last=rec.pauses[rec.pauses.length-1]; if(last && !last.end) last.end=Date.now();
  paused=false;
  
  // Restart session timer when unpaused
  if(sessionActive) startSessionTimer();
}
function pauseResume(){
  if(!sessionActive) return;
  if(paused){ pauseEnd(); safe('btnPause', el=> el.textContent='‚è∏ Pause'); if(special) nextSpecialTrial(); else if(currentNote){ nextTrial(false); } }
  else { safe('btnPause', el=> el.textContent='‚ñ∂ Resume'); pauseStart('user'); }
}

/* ------------------ QUOTA ------------------ */
function quotaStart(){ if(state.capResetAt && Date.now() >= state.capResetAt) return state.capResetAt; const d = new Date(); d.setHours(0,0,0,0); return d.getTime(); }
function msUsedQuota(){ const start = quotaStart(); return (state.sessions || []).filter(s => s.start >= start).reduce((a, s) => a + activeDuration(s), 0); }

/* ------------------ PROGRESS / CHARTS ------------------ */
function eightWeekBins(pitch){
  const t0=todayKey(Date.now());
  const bins=[];
  for(let w=1; w<=8; w++){ const start=t0 - (w-1)*7*86400000; const end=start+7*86400000; bins.push({w,start,end,n:0,ok:0}); }
  const oldest=bins[7].start;
  const trials=(state.trials||[]).filter(tr=>{
    const d=dateAtMidnight(tr.time);
    return d>=oldest && d<bins[0].end && (pitch==='OVERALL'|| tr.pc===pitch);
  });
  for(const tr of trials){
    const d=dateAtMidnight(tr.time);
    const daysAgo=Math.floor((t0 - d)/86400000);
    const w=Math.floor(daysAgo/7)+1;
    const idx=Math.min(8,Math.max(1,w))-1;
    const b=bins[idx]; b.n++; if(tr.correct) b.ok++;
  }
  return bins;
}
function thisWeekBins(pitch){
  const ws = weekStartTs();
  const bins=[];
  for(let i=0;i<7;i++){ bins.push({day:i+1,start:ws+i*86400000,end:ws+(i+1)*86400000,n:0,ok:0}); }
  const trials=(state.trials||[]).filter(tr=> tr.time>=ws && tr.time<ws+7*86400000 && (pitch==='OVERALL'|| tr.pc===pitch));
  for(const tr of trials){
    const day = Math.floor((dateAtMidnight(tr.time) - ws)/86400000);
    const b = bins[Math.max(0, Math.min(6, day))]; b.n++; if(tr.correct) b.ok++;
  }
  return bins;
}
function drawLine(ctx, pts, color, xscale, yscale){ ctx.beginPath(); let started=false; for(const p of pts){ if(p.y===null) continue; const x=xscale(p.x), y=yscale(p.y); if(!started){ ctx.moveTo(x,y); started=true; } else ctx.lineTo(x,y); } if(!started) return; ctx.strokeStyle=color; ctx.lineWidth=2.5; ctx.stroke(); }
function drawDot(ctx, x, y, color, r=6){ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fillStyle=color; ctx.fill(); }
function drawChart(){
  const canvas = byId('progressCanvas'); if(!canvas) return;
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  ctx.clearRect(0,0,W,H);
  const P={l:56,r:24,t:16,b:28}; const AX=P.l, AY=P.t, AW=W-P.l-P.r, AH=H-P.t-P.b;
  const colCard = getComputedStyle(document.documentElement).getPropertyValue('--card') || '#1e293b';
  ctx.fillStyle=colCard; ctx.fillRect(0,0,W,H);
  const mode=byId('granularitySelect')?.value||'WEEKLY';
  const pitch=byId('pitchSelect')?.value||'OVERALL';
  const colGood=getComputedStyle(document.documentElement).getPropertyValue('--good')||'#16a34a';
  const colNeutral=getComputedStyle(document.documentElement).getPropertyValue('--neutral')||'#94a3b8';
  const colMuted=getComputedStyle(document.documentElement).getPropertyValue('--muted')||'#334155';
  const colText=getComputedStyle(document.documentElement).getPropertyValue('--text')||'#e5e7eb';
  const yscale=(v)=> AY + AH - (v/100)*AH;

  /* Y grid + labels */
  ctx.strokeStyle=colMuted; ctx.lineWidth=1; ctx.beginPath();
  for(let gy=0; gy<=100; gy+=20){ const y=yscale(gy); ctx.moveTo(AX,y); ctx.lineTo(AX+AW,y);} ctx.stroke();
  ctx.fillStyle=colText; ctx.font='12px system-ui,sans-serif';
  for(let gy=0; gy<=100; gy+=20){ const y=yscale(gy)+4; ctx.fillText(String(gy)+'%', 8, y); }

  if(mode==='WEEKLY'){
    const bins=thisWeekBins(pitch);
    const xscale=(d)=> AX + ((d - 1)/(7 - 1))*AW;
    ctx.strokeStyle=colMuted; ctx.beginPath();
    for(let d=1; d<=7; d++){ const x=xscale(d); ctx.moveTo(x,AY); ctx.lineTo(x,AY+AH);} ctx.stroke();
    ctx.fillStyle=colText;
    for(let d=1; d<=7; d++){ const x=xscale(d); ctx.fillText(`Day ${d}`, x-18, H-6); }
    const pts=bins.map(b=> b.n===0? {x:b.day,y:null}:{x:b.day,y:Math.round((b.ok/b.n)*1000)/10});
    const accPts=pts.filter(p=> p.y!==null);
    drawLine(ctx,accPts,colGood,xscale,yscale);
    for(const b of bins){
      if(b.n>0) drawDot(ctx,xscale(b.day), yscale(Math.round((b.ok/b.n)*1000)/10), colGood, 6);
      else      drawDot(ctx,xscale(b.day), yscale(0), colNeutral, 5);
    }
  } else {
    const weeks=eightWeekBins(pitch);
    const xscale=(w)=> AX + ((w - 1)/(8 - 1))*AW;
    ctx.strokeStyle=colMuted; ctx.beginPath();
    for(let w=1; w<=8; w++){ const x=xscale(w); ctx.moveTo(x,AY); ctx.lineTo(x,AY+AH);} ctx.stroke();
    ctx.fillStyle=colText;
    for(let w=1; w<=8; w++){ const x=xscale(w); ctx.fillText(`Week ${w}`, x-22, H-6); }
    const pts=weeks.map(b=> b.n===0? {x:b.w,y:null}:{x:b.w,y:Math.round((b.ok/b.n)*1000)/10});
    const accPts=pts.filter(p=> p.y!==null);
    drawLine(ctx,accPts,colGood,xscale,yscale);
    for(const p of weeks){
      if(p.n>0) drawDot(ctx,xscale(p.w), yscale(Math.round((p.ok/p.n)*1000)/10), colGood, 5);
      else      drawDot(ctx,xscale(p.w), yscale(0), colNeutral, 4);
    }
  }
  ctx.fillStyle=colText; ctx.font='13px system-ui,sans-serif';
  const label=(pitch==='OVERALL')?'Overall':`Pitch: ${pcLabel(pitch)}`;
  ctx.fillText(label, AX, AY-2);
}

/* Pitch dropdown + view toggle */
function populatePitchSelect(){
  const sel = byId('pitchSelect'); if(!sel) return;
  sel.innerHTML='';
  const mk=(v,t)=>{ const o=document.createElement('option'); o.value=v; o.textContent=t; return o; };
  sel.appendChild(mk('OVERALL','Overall'));
  PC.forEach(pc=> sel.appendChild(mk(pc, pcLabel(pc))));
  sel.onchange = ()=> drawChart();
  const gran = byId('granularitySelect'); if(gran){ gran.onchange = ()=> drawChart(); gran.value='WEEKLY'; }
}

/* ------------------ TUTORIAL PAGER ------------------ */
let tIndex = 0;
function setTutorialPage(i){
  tIndex = Math.max(0, Math.min(5, i));
  ['tPage1','tPage2','tPage3','tPage4','tPage5','tPage6'].forEach((id, idx)=>{
    const el = byId(id);
    if(el) el.classList.toggle('active', idx===tIndex);
  });
  const back = byId('tBack'); if(back) back.style.visibility = (tIndex===0 ? 'hidden' : 'visible');
  const next = byId('tNext'); if(next) next.textContent = (tIndex===5 ? 'Got it' : 'Next ‚ñ∂');
}
function nextTutorial(){ if(tIndex<5){ setTutorialPage(tIndex+1); return; } hide('welcomeModal'); showScreen('menuScreen'); updateCapsUI(); populatePitchSelect(); drawChart(); }
function prevTutorial(){ setTutorialPage(tIndex-1); }

/* ------------------ WIRING ------------------ */
function wireOnce(){
  sealDanglingSession();
  try{ populatePitchSelect(); drawChart(); }catch(_){}
  // Start
  safe('startBtn', el=> el.onclick=()=>{
    const name=(byId('userNameInput')?.value||'').trim()||'Player';
    state.userName=name; save();
    safe('greeting', g=> g.textContent=`Hello ${state.userName}!`);
    showFlex('welcomeModal'); setTutorialPage(0);
  });
  safe('tNext', el=> el.onclick=()=> nextTutorial());
  safe('tBack', el=> el.onclick=()=> prevTutorial());

  // Menu
  safe('menuStart',   el=> el.onclick=()=> startSession());
  safe('startAssessment', el=> el.onclick=()=> startAssessment());
  safe('viewTracker', el=> el.onclick=()=> showTracker());
  safe('exportData',  el=> el.onclick=()=> exportTrainingData());
  safe('playFlappy',  el=> el.onclick=()=> openFlappyFromMenu());
  safe('resetLockout',el=> el.onclick=()=>{
    if(!confirm('Reset lockout/timer now? This starts a fresh 30-minute window immediately.')) return;
    state.lockoutUntil = null; state.capResetAt = Date.now(); state.lastSeen = Date.now();
    save(); updateCapsUI(); alert('Timer reset. You can start training now.');
  });
  safe('menuReset',   el=> el.onclick=()=> doFactoryReset());

  // Assessment warning modal
  safe('btnProceedAssessment', el=> el.onclick=()=> proceedWithAssessment());
  safe('btnCancelAssessment', el=> el.onclick=()=> cancelAssessment());
  
  // Assessment results modal
  safe('btnRetakeAssessmentModal', el=> el.onclick=()=> {
    byId('assessmentResultsModal').style.display = 'none';
    proceedWithAssessment();
  });
  safe('btnBackMenuModal', el=> el.onclick=()=> {
    byId('assessmentResultsModal').style.display = 'none';
    showScreen('menuScreen'); 
    populatePitchSelect(); 
    drawChart();
  });

  // Assessment screen
  safe('btnStartAssessment', el=> el.onclick=()=> beginAssessment());
  safe('btnBackMenuAssessment', el=> el.onclick=()=> { assessmentActive=false; showScreen('menuScreen'); populatePitchSelect(); drawChart(); });
  safe('btnRetryAssessment', el=> el.onclick=()=> { hide('assessmentResults'); beginAssessment(); });
  safe('btnBackMenuFromResults', el=> el.onclick=()=> { assessmentActive=false; showScreen('menuScreen'); populatePitchSelect(); drawChart(); });

  // Tracker screen
  safe('btnBackMenuTracker', el=> el.onclick=()=> { showScreen('menuScreen'); populatePitchSelect(); drawChart(); });

  // Set selector
  safe('setSizeSelect', sel=>{
    if(!sel.options.length){
      for(let i=1;i<=SETS;i++){
        const o=document.createElement('option');
        o.value=i; o.textContent=`${i} ${i===1?'pitch':'pitches'}`;
        sel.appendChild(o);
      }
    }
    sel.value = String(setFromIndex(state.levelIndex));
  });
  safe('applySetBtn', el=> el.onclick=()=>{
    const v = parseInt(byId('setSizeSelect')?.value||'1',10)||1;
    state.levelIndex=(v-1)*LEVELS_PER_SET+1; state.levelTrials=0; state.levelCorrect=0; state.testFailStreak=0; suggestedRestartFlag=false; state.suggestShownSet=null; save();
    alert(`Scope set to ${v} ${v===1?'pitch':'pitches'} (Block 1/24)`); paintNotes();
  });

  // Audio type selection
  safe('audioTypeSelect', el=> {
    el.value = state.audioType || AUDIO_TYPES.PIANO;
  });
  safe('applyAudioBtn', el=> el.onclick=()=>{
    const newType = byId('audioTypeSelect')?.value || AUDIO_TYPES.PIANO;
    state.audioType = newType;
    save();
    const labels = {
      [AUDIO_TYPES.PIANO]: 'Piano (C3-C5)',
      [AUDIO_TYPES.SINE]: 'Sine Wave (C3-C5)', 
      [AUDIO_TYPES.GUITAR]: 'Guitar (C3-C5)'
    };
    alert(`Audio changed to ${labels[newType] || 'Piano'}`);
  });

  // Variety mode toggle
  safe('varietyModeToggle', el=> {
    el.checked = state.varietyModeEnabled || false;
    el.onchange = ()=> {
      state.varietyModeEnabled = el.checked;
      updateVarietyModeUI();
      save();
    };
  });
  
  safe('varietyInfoBtn', el=> el.onclick=()=>{
    const explanation = `Variety Mode adds timbre diversity to your training:

‚Ä¢ Weeks 1-2: 100% your chosen audio type (faster early learning)
‚Ä¢ Week 3+: 80% chosen type, 20% rotating alternate type
‚Ä¢ Changes daily to prevent over-adaptation
‚Ä¢ Weak notes get extra practice in struggling timbres
‚Ä¢ Helps build robust pitch recognition across instruments`;
    
    alert(explanation);
  });
  
  updateVarietyModeUI();

  // Debug toggle - only show if DEV_UI is enabled
  if (DEV_UI) {
    safe('debugToggle', el=> {
      el.style.display = 'inline-block';
      el.onclick=()=>{
        const panel = byId('debugPanel');
        if(panel.style.display === 'none') {
          panel.style.display = 'block';
          updateDebugInfo();
          el.textContent = 'Hide Debug';
        } else {
          panel.style.display = 'none';
          el.textContent = 'Debug';
        }
      };
    });
  }

  // Theme selection
  safe('themeSelect', el=> {
    el.value = state.theme || 'default';
  });
  safe('applyThemeBtn', el=> el.onclick=()=>{
    const newTheme = byId('themeSelect')?.value || 'default';
    state.theme = newTheme;
    save();
    applyTheme(newTheme);
    const themeName = THEMES[newTheme]?.name || 'Dark Ocean';
    alert(`Theme changed to ${themeName}`);
  });

  // Trainer controls
  safe('btnPlay',        el=> el.onclick=async()=>{ firstRtBonusMs=2000; await resumeCtx(); if(paused){ pauseEnd(); } safe('btnPause', b=> b.textContent='‚è∏ Pause'); if(special) nextSpecialTrial(); else nextTrial(true); });
  safe('btnPause',       el=> el.onclick=()=> pauseResume());
  safe('btnBackMenu',    el=> el.onclick=()=>{
    if(sessionActive){ if(!paused) pauseStart('user-leave'); openStrictModal(); }
    else { showScreen('menuScreen'); populatePitchSelect(); drawChart(); }
  });
  safe('btnToggleAuto',  el=> el.onclick=()=>{
    autoNext=!autoNext; textWithTooltip('autoInfo',`Auto-next: ${autoNext?'On':'Off'}`);
    const sl=byId('delaySlider'); if(sl){ sl.disabled=!autoNext; sl.classList.toggle('disabled', !autoNext); }
    if(!autoNext && autoTimer){ clearTimeout(autoTimer); autoTimer=null; }
  });
  safe('delaySlider', sl=>{
    sl.disabled=true; sl.classList.add('disabled');
    sl.oninput=(e)=>{ delayMs=parseInt(e.target.value,10)||0; updateLevelUI(); };
  });

  // Specials
  safe('btnTarget',el=> el.onclick=()=> answerSpecial(true));
  safe('btnOther', el=> el.onclick=()=> answerSpecial(false));

  // Strict modal buttons
  safe('btnStrictResume', el=> el.onclick=()=>{ closeStrictModal(); showScreen('trainerScreen'); initializeTooltips(); });
  safe('btnStrictMenu',   el=> el.onclick=()=>{ closeStrictModal(); showScreen('menuScreen'); });

  // New pitch modal buttons
  safe('btnHearNewPitch', el=> el.onclick=async()=>{ 
    const pitch = UNLOCK_ORDER[setFromIndex(state.levelIndex) - 1];
    await playNewPitchDemo(pitch); 
  });
  safe('btnContinueTraining', el=> el.onclick=()=>{ 
    closeNewPitchModal(); 
    startFlappyReward(); 
  });

  // Recall modal buttons
  safe('btnStartRecording', el=> el.onclick=()=> startRecallRecording());
  safe('btnStopRecording', el=> el.onclick=()=> stopRecallRecording());
  safe('btnSkipRecall', el=> el.onclick=()=> skipRecallTest());
  safe('btnNextRecall', el=> el.onclick=()=> nextRecallNote());
  safe('btnFinishRecall', el=> el.onclick=()=> finishRecallTest());

  
  // Set up event listeners for guess buttons (data-guess and data-oob)
  document.addEventListener('click', (e) => {
    if (e.target.dataset.guess) {
      e.preventDefault();
      guess(e.target.dataset.guess);
    } else if (e.target.dataset.oob) {
      e.preventDefault();
      chooseOOB();
    }
  });

  // Initial screen
  if(!state.userName){ showScreen('startScreen'); }
  else { safe('greeting', g=> g.textContent=`Hello ${state.userName}!`); showScreen('menuScreen'); updateCapsUI(); }
}

/* ------------------ FLAPPY ------------------ */
let fCtx, flappyRAF=null, running=false, score=0, pipes=[], bird, pipeTimer=0, lastTs=null;

/* Flappy now: start with bigger gap, shrink over first 5 pipes, then keep constant.
   Speed still scales with score. */
const FLAPPY = { gravity:900, flap:-380, baseSpeed:140, maxSpeed:260, speed:140, baseGap:140, gap:140, introPipes:5, introExtra:60, spawnEvery:1.20, width:52 };

function openFlappyFromMenu(){ if(isLocked()) openFlappyModal(); else alert('Flappy is intended for lockout/rewards.'); }

/* Mandatory Break System */
function triggerMandatoryBreak(){
  if(!sessionActive || state.inBreak) return;
  
  // Pause the session and start break
  if(!paused) pauseStart('mandatory-break');
  state.inBreak = true;
  state.lastBreakTime = Date.now();
  
  // Schedule next break in 6 minutes from now
  state.sessionBreakTime = Date.now() + BREAK_INTERVAL_MS;
  save();
  
  // Hide training chunk display during break
  const chunkEl = byId('chunkInfo');
  if(chunkEl) chunkEl.textContent = 'Break in progress...';
  
  // Show Flappy with lockout sound (always enabled during mandatory breaks)
  openMandatoryBreakFlappy();
}

function openMandatoryBreakFlappy(){
  byId('flappyModal').style.display='flex'; 
  const c=byId('flappyCanvas'); 
  if(!c) return; 
  fCtx=c.getContext('2d'); 
  resetFlappy(); 
  attachFlappyControls();
  
  // Update UI to show this is a mandatory break
  const modalTitle = byId('flappyModal').querySelector('h3');
  if(modalTitle) modalTitle.textContent = '‚è±Ô∏è Mandatory 60s Break';
  
  // Show sound toggle and set appropriate description
  const soundToggle = byId('flappySoundToggle');
  const description = byId('flappyModal').querySelector('p:last-child');
  if (soundToggle) {
    soundToggle.style.display = 'inline-block';
    soundToggle.textContent = state.flappySoundEnabled ? 'üîä Sound On' : 'üîá Sound Off';
  }
  if (description) {
    description.textContent = 'Mandatory 60-second break. Tap/click (or Space) to flap ‚Äî each flap makes a flappy sound.';
  }
  
  // Start the break timer
  startBreakTimer();
}

function startBreakTimer(){
  // Show countdown display
  const countdownEl = byId('breakCountdown');
  if(countdownEl) countdownEl.style.display = 'block';
  
  const startTime = Date.now();
  
  // Update countdown every second
  const countdownInterval = setInterval(() => {
    const elapsed = Date.now() - startTime;
    const remaining = Math.max(0, BREAK_DURATION_MS - elapsed);
    const seconds = Math.ceil(remaining / 1000);
    
    if(countdownEl) {
      countdownEl.textContent = `Break ends in: ${seconds}s`;
    }
    
    if(remaining <= 0) {
      clearInterval(countdownInterval);
    }
  }, 1000);
  
  // Force close after 60 seconds minimum, but allow game to continue if in progress
  setTimeout(() => {
    clearInterval(countdownInterval);
    if(countdownEl) countdownEl.style.display = 'none';
    
    if(state.inBreak) {
      // Check if user is still playing - if so, let them finish their current game
      if(running && bird && bird.y > 0 && bird.y < byId('flappyCanvas')?.height) {
        // Game is active, wait for it to end naturally
        const checkGameEnd = setInterval(() => {
          if(!running) {
            clearInterval(checkGameEnd);
            endMandatoryBreak();
          }
        }, 100);
      } else {
        // Game not active or already ended, close immediately
        endMandatoryBreak();
      }
    }
  }, BREAK_DURATION_MS);
}

function endMandatoryBreak(){
  if(!state.inBreak) return;
  
  // Store minutesToday before break ends to verify it doesn't change
  const minutesTodayBeforeBreak = state.minutesToday;
  
  // Close Flappy
  running = false;
  cancelAnimationFrame(flappyRAF);
  byId('flappyModal').style.display = 'none';
  detachFlappyControls();
  
  // Reset modal title
  const modalTitle = byId('flappyModal').querySelector('h3');
  if(modalTitle) modalTitle.textContent = 'üê§ Flappy Break';
  
  // Hide break countdown
  const countdownEl = byId('breakCountdown');
  if(countdownEl) countdownEl.style.display = 'none';
  
  // End break state and schedule next break
  state.inBreak = false;
  state.sessionBreakTime = Date.now() + BREAK_INTERVAL_MS; // Next break in 6 minutes
  save();
  
  // Console assert that minutesToday is unchanged during break
  console.assert(state.minutesToday === minutesTodayBeforeBreak, 
    `minutesToday changed during break: before=${minutesTodayBeforeBreak}, after=${state.minutesToday}`);
  
  // Resume session
  if(sessionActive) {
    pauseEnd();
    safe('btnPause', el=> el.textContent='‚è∏ Pause');
    currentNote = null;
    clearTimeout(rtTimer); rtTimer = null;
    clearTimeout(autoTimer); autoTimer = null;
    text('promptPill', 'Break over ‚Äî press Play to continue');
  }
}
function openFlappyModal(){ 
  byId('flappyModal').style.display='flex'; 
  const c=byId('flappyCanvas'); 
  if(!c) return; 
  fCtx=c.getContext('2d'); 
  resetFlappy(); 
  attachFlappyControls();
  
  // Show sound toggle button and update description when in lockout
  const soundToggle = byId('flappySoundToggle');
  const description = byId('flappyModal').querySelector('p:last-child');
  if (isLocked()) {
    if (soundToggle) {
      soundToggle.style.display = 'inline-block';
      soundToggle.textContent = state.flappySoundEnabled ? 'üîä Sound On' : 'üîá Sound Off';
    }
    if (description) {
      description.textContent = 'Tap/click (or Space) to flap. First tap starts ‚Äî each flap makes a flappy sound.';
    }
  } else {
    if (soundToggle) soundToggle.style.display = 'none';
    if (description) {
      description.textContent = 'Tap/click (or Space) to flap. First tap starts ‚Äî each flap plays a random pitch.';
    }
  }
}
function startFlappyReward(){ if(sessionActive && !paused){ pauseStart('flappy'); } clearTimeout(rtTimer); rtTimer=null; clearTimeout(autoTimer); autoTimer=null; openFlappyModal(); }
function closeFlappy(){
  running=false; cancelAnimationFrame(flappyRAF); byId('flappyModal').style.display='none'; detachFlappyControls();
  if(score > (state.flappyHighScore||0)){ state.flappyHighScore = score; save(); }
  if(sessionActive){
    safe('btnPause', el=> el.textContent='‚ñ∂ Resume');
    currentNote=null; clearTimeout(rtTimer); rtTimer=null; clearTimeout(autoTimer); autoTimer=null;
    text('promptPill','Flappy over ‚Äî press Play to continue');
  }
}
function resetFlappy(){ const cnv=byId('flappyCanvas'); if(!cnv) return; bird={x:60,y:cnv.height/2,vy:0,wing:0}; pipes=[]; score=0; pipeTimer=0; lastTs=null; FLAPPY.speed=FLAPPY.baseSpeed; FLAPPY.gap=FLAPPY.baseGap + FLAPPY.introExtra; FLAPPY.introPipes=5; text('flappyScore',`Score: 0 ‚Ä¢ Best: ${state.flappyHighScore||0}`); }
function flap(){ 
  bird.vy = FLAPPY.flap; 
  
  // Use flappy sound for lockout or mandatory breaks, musical pitches otherwise
  if (state.flappySoundEnabled && (isLocked() || state.inBreak)) {
    playFlappySound();
  } else if (state.flappySoundEnabled && !isLocked() && !state.inBreak) {
    // Regular flappy bird with musical pitches
    const pc = rand(PC); 
    const note = `${pc}${rand(currentOctaves())}`; 
    playSample(note);
  }
}
function progressiveDifficulty(){ // only speed scales; gap remains constant after intro
  const target = FLAPPY.baseSpeed + Math.min(Math.floor(score/5)*18, FLAPPY.maxSpeed - FLAPPY.baseSpeed);
  FLAPPY.speed = target;
}
function drawBird(){ const ctx=fCtx; if(!ctx) return; const body=getComputedStyle(document.documentElement).getPropertyValue('--accent')||'#fbbf24'; const wingCol=getComputedStyle(document.documentElement).getPropertyValue('--good')||'#16a34a'; const outline=getComputedStyle(document.documentElement).getPropertyValue('--bg')||'#0f172a';
  ctx.save();
  const tilt=Math.max(-0.6,Math.min(0.6,bird.vy/380)); ctx.translate(bird.x,bird.y); ctx.rotate(tilt);
  ctx.fillStyle=body; ctx.beginPath(); ctx.arc(0,0,10,0,Math.PI*2); ctx.fill();
  ctx.fillStyle=getComputedStyle(document.documentElement).getPropertyValue('--text')||'#e5e7eb'; ctx.beginPath(); ctx.arc(3,-4,3,0,Math.PI*2); ctx.fill();
  ctx.fillStyle=outline; ctx.beginPath(); ctx.arc(4,-4,1.5,0,Math.PI*2); ctx.fill();
  bird.wing+=0.25; const wing=Math.sin(bird.wing)*0.9; ctx.save(); ctx.rotate(wing);
  ctx.fillStyle=wingCol; ctx.beginPath(); ctx.moveTo(-2,2); ctx.quadraticCurveTo(-16,4,-8,12); ctx.quadraticCurveTo(0,10,-2,2); ctx.fill();
  ctx.strokeStyle='rgba(0,0,0,0.35)'; ctx.lineWidth=1.5; ctx.stroke();
  ctx.restore();
  ctx.restore();
}
function drawPipes(){ const ctx=fCtx; if(!ctx) return; const col=getComputedStyle(document.documentElement).getPropertyValue('--good')||'#16a34a'; ctx.fillStyle=col; const cnv=byId('flappyCanvas'); if(!cnv) return; for(const p of pipes){ const topH=p.gapY-FLAPPY.gap/2, bottomY=p.gapY+FLAPPY.gap/2; ctx.fillRect(p.x,0,FLAPPY.width,topH); ctx.fillRect(p.x,bottomY,FLAPPY.width,cnv.height-bottomY); } }
function spawnPipe(){
  const cnv=byId('flappyCanvas'); if(!cnv) return;
  const h=cnv.height, m=40;

  // intro ramp: linearly reduce gap to baseGap across first 5 pipes
  if(FLAPPY.introPipes > 0){
    const k = FLAPPY.introPipes; // 5..1
    const extraNow = Math.round(FLAPPY.introExtra * (k/5));
    FLAPPY.gap = FLAPPY.baseGap + extraNow;
    FLAPPY.introPipes--;
    if(FLAPPY.introPipes === 0) FLAPPY.gap = FLAPPY.baseGap; // lock it
  }

  const gapY=Math.max(m,Math.min(h-m-FLAPPY.gap,Math.random()*(h-FLAPPY.gap-2*m)))+FLAPPY.gap/2;
  pipes.push({x: cnv.width, gapY: gapY, passed:false});
}
function step(ts){
  if(!running) return;
  const cnv=byId('flappyCanvas'); if(!cnv) return;
  if(lastTs===null) lastTs = ts;
  let dt = (ts - lastTs) / 1000; if(dt > 0.033) dt = 0.033; lastTs = ts;
  bird.vy += FLAPPY.gravity * dt; bird.y  += bird.vy * dt;
  pipeTimer -= dt; if(pipeTimer <= 0){ pipeTimer += FLAPPY.spawnEvery; spawnPipe(); }
  for(const p of pipes){ p.x -= FLAPPY.speed * dt; }
  for(const p of pipes){ if(!p.passed && p.x + FLAPPY.width < bird.x){ p.passed = true; score++; progressiveDifficulty(); text('flappyScore',`Score: ${score} ‚Ä¢ Best: ${state.flappyHighScore||0}`); } }
  pipes = pipes.filter(p=> p.x + FLAPPY.width > 0);
  fCtx.clearRect(0,0,cnv.width,cnv.height); drawPipes(); drawBird();
  if(bird.y < 0 || bird.y > cnv.height){ return closeFlappy(true); }
  for(const p of pipes){ if(bird.x+10>p.x && bird.x-10<p.x+FLAPPY.width){ const topH=p.gapY-FLAPPY.gap/2, bottomY=p.gapY+FLAPPY.gap/2; if(bird.y-10<topH || bird.y+10>bottomY){ return closeFlappy(true); } } }
  flappyRAF = requestAnimationFrame(step);
}
let _flHandlers=null;
function attachFlappyControls(){
  const cnv=byId('flappyCanvas'); if(!cnv) return;
  const startOrFlap = () => { if(!running){ running=true; resetFlappy(); flappyRAF=requestAnimationFrame(step); } else { flap(); } };
  const onCanvasClick  = (e)=>{ e.preventDefault(); startOrFlap(); };
  const onTouchStart   = (e)=>{ e.preventDefault(); startOrFlap(); };
  const onKey          = (e)=>{ if(e.code==='Space'){ e.preventDefault(); startOrFlap(); } };
  const onClose        = ()=> closeFlappy(false);
  cnv.addEventListener('click', onCanvasClick);
  cnv.addEventListener('touchstart', onTouchStart, { passive:false });
  window.addEventListener('keydown', onKey);
  safe('flappyClose', el=> el.onclick=onClose);
  safe('flappySoundToggle', el=> el.onclick=()=> {
    state.flappySoundEnabled = !state.flappySoundEnabled;
    save();
    el.textContent = state.flappySoundEnabled ? 'üîä Sound On' : 'üîá Sound Off';
  });
  _flHandlers={onCanvasClick,onTouchStart,onKey,onClose};
}
function detachFlappyControls(){
  const cnv=byId('flappyCanvas'); if(!_flHandlers||!cnv) return;
  cnv.removeEventListener('click', _flHandlers.onCanvasClick);
  cnv.removeEventListener('touchstart', _flHandlers.onTouchStart);
  window.removeEventListener('keydown', _flHandlers.onKey);
  safe('flappyClose', el=> el.onclick=null);
  safe('flappySoundToggle', el=> el.onclick=null);
}

/* ------------------ STRICT MODAL + NAV GUARDS ------------------ */
let strictModalPending=false;
function openStrictModal(){ if(suppressStrictOnce){ suppressStrictOnce=false; return; } showFlex('strictModal'); setTimeout(()=> byId('btnStrictResume')?.focus(), 0); }
function closeStrictModal(){ hide('strictModal'); strictModalPending=false; }

/* New Pitch Modal */
function showNewPitchModal(setNumber){
  const newPitch = UNLOCK_ORDER[setNumber - 1];
  text('newPitchName', pcLabel(newPitch));
  showFlex('newPitchModal');
  setTimeout(()=> byId('btnHearNewPitch')?.focus(), 0);
}
function closeNewPitchModal(){
  hide('newPitchModal');
}
async function playNewPitchDemo(pitch){
  try{
    await resumeCtx();
    const octaves = currentOctaves();
    
    // Play the pitch slowly across all three octaves
    for(let i = 0; i < octaves.length; i++){
      const note = `${pitch}${octaves[i]}`;
      await playSample(note);
      // Wait 1.2 seconds between notes for slow demonstration  
      await new Promise(resolve => setTimeout(resolve, 1200));
    }
  }catch(e){
    report(e);
  }
}
function reconcileAwayTime(){
  const now = Date.now();
  const rec = (state.sessions||[])[(state.sessions||[]).length - 1];
  if(rec && rec.pauses && rec.pauses.length){
    const openPause = rec.pauses[rec.pauses.length-1];
    if(openPause && !openPause.end){ openPause.end = now; save(); }
  }
  state.lastSeen = now; save();
}
document.addEventListener('visibilitychange', ()=>{
  if(document.hidden && sessionActive && !paused){ pauseStart('hidden'); strictModalPending = true; }
  if(!document.hidden){ reconcileAwayTime(); if(strictModalPending && !suppressStrictOnce) openStrictModal(); strictModalPending=false; }
});
window.addEventListener('blur', ()=>{ if(sessionActive && !paused){ pauseStart('blur'); strictModalPending = true; } });
window.addEventListener('focus', ()=>{ reconcileAwayTime(); if(strictModalPending && !suppressStrictOnce) openStrictModal(); strictModalPending=false; });
window.addEventListener('pagehide', ()=>{ try{ if(sessionActive && !paused){ pauseStart('pagehide'); strictModalPending = true; } state.lastSeen = Date.now(); save(); }catch(_){}});

/* --- beforeunload guard --- */
let allowUnloadOnce = false;
window.addEventListener('beforeunload', (e)=>{
  if(allowUnloadOnce) return;
  if(sessionActive && !paused){ e.preventDefault(); e.returnValue=''; }
});

/* ------------------ FACTORY RESET ------------------ */
async function wipeAllStorage(){ try{ localStorage.clear(); }catch(_){}
  try{ sessionStorage.clear(); }catch(_){}
  if('caches' in window){ try{ const keys = await caches.keys(); await Promise.all(keys.map(k=>caches.delete(k))); }catch(_){ } }
  if('indexedDB' in window){
    try{
      if(indexedDB.databases){
        const dbs = await indexedDB.databases();
        await Promise.all((dbs||[]).map(db=> db && db.name ? new Promise(res=>{ const rq = indexedDB.deleteDatabase(db.name); rq.onsuccess=rq.onerror=rq.onblocked=()=>res(); }) : Promise.resolve()));
      }
    }catch(_){}
  }
}
function forceStartScreen(){
  document.querySelectorAll('.screen').forEach(el=> el.style.display='none');
  const input = byId('userNameInput');
  byId('startScreen').style.display='block';
  if(input){ input.value=''; input.focus(); }
}
function resetInMemoryStateToDefaults(){
  state = { userName:null, levelIndex:1, levelTrials:0, levelCorrect:0, sessions:[], trials:[], startDate:null, lockoutUntil:null, capResetAt:null, testFailStreak:0, suggestShownSet:null, lastSeen:null, flappyHighScore:0, thisWeekIdx:0, thisWeekMs:0, levelFailCounts:{}, specialRanForLevel:null };
  save();
}
function doFactoryReset(){
  (async ()=>{
    try{
      if(!confirm('Reset EVERYTHING to factory settings? This erases your progress, timers, and settings.')) return;
      stopAllTimers(); sessionActive=false; paused=false;
      await closeAudio(); await wipeAllStorage(); resetInMemoryStateToDefaults(); forceStartScreen();
      allowUnloadOnce = true; setTimeout(()=>{ try{ location.reload(); }catch(_){ } }, 0);
    }catch(e){ report(e); alert('Reset failed: '+e.message); }
  })();
}

/* ------------------ SANITY GUARDS & DEBUG ------------------ */
// F) SANITY GUARDS (dev-only console asserts ok)
function validateOOBState() {
  console.assert(state.oobStats.adaptiveRate >= 0.05 && state.oobStats.adaptiveRate <= 0.35, 'OOB rate clamp failed');
  if (isOOBTrial) console.assert(currentTrialJitter?.jitter === 0, 'OOB must be 0¬¢');
  if (currentNote) {
    const octave = parseInt(currentNote.slice(-1));
    console.assert([3,4,5].includes(octave), 'Octave outside 3‚Äì5');
  }
}

// Tiny helper:
window.getOOBDebug = () => {
  const last60 = (state.trials||[]).filter(t=>!t.oob).slice(-60);
  const acc = last60.length ? last60.reduce((a,t)=>a+(t.correct?1:0),0)/last60.length : null;
  return { rate: state.oobStats.adaptiveRate, maxInRow: state.oobStats.maxInRow, last60InBoundsAcc: acc };
};

// Track OOB time-series at block end for QA export
function trackBlockEndOOBSeries(blockIdx) {
  // Calculate current block's OOB percentage
  const blockTrials = state.trials.slice(-40); // Last 40 trials (current block)
  const blockOOBTrials = blockTrials.filter(t => t.oob);
  const observedPct = blockTrials.length > 0 ? 
    num(blockOOBTrials.length / blockTrials.length, 0) : 0;
  
  // Calculate last 60 in-bounds accuracy
  const last60InBounds = state.trials.filter(t => !t.oob).slice(-60);
  const last60Acc = last60InBounds.length > 0 ? 
    num(last60InBounds.filter(t => t.correct).length / last60InBounds.length, 0) : 0;
  
  // Get current target percentage
  const targetPct = num(state.oobStats?.adaptiveRate || 0.18, 0.18);
  
  // Initialize QA structures if needed
  if (!state.qa) state.qa = {};
  if (!state.qa.oob) state.qa.oob = {};
  if (!state.qa.oob.series) state.qa.oob.series = [];
  if (!state.qa.curriculum) state.qa.curriculum = {
    activePitches: [],
    weights: {},
    blockBoundaries: []
  };
  
  // Add block end entry for OOB series
  state.qa.oob.series.push({
    blockIdx: blockIdx,
    targetPct: targetPct,
    observedPct: observedPct,
    last60Acc: last60Acc,
    timestamp: Date.now()
  });
  
  // Track curriculum state at block boundary
  const currentSet = setFromIndex(state.levelIndex);
  const activePitches = trainedSet(currentSet);
  
  state.qa.curriculum.blockBoundaries.push({
    blockIdx: blockIdx,
    activePitches: [...activePitches].sort(),
    weights: { ...state.curriculum.weights },
    set: currentSet,
    timestamp: Date.now()
  });
  
  // Keep only last 100 entries to avoid memory bloat
  if (state.qa.oob.series.length > 100) {
    state.qa.oob.series = state.qa.oob.series.slice(-100);
  }
  if (state.qa.curriculum.blockBoundaries.length > 100) {
    state.qa.curriculum.blockBoundaries = state.qa.curriculum.blockBoundaries.slice(-100);
  }
}

/* ------------------ OFFLINE SIMULATOR ------------------ */

// Seeded RNG (mulberry32) for reproducible simulations
function mulberry32(a) {
  return function() {
    let t = a += 0x6D2B79F5;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}

// Simulation constants
const SIM_TRIALS_PER_BLOCK = 20;
const SIM_DAILY_BLOCKS = 5;

// Global simulation state
let SIMULATING = false;
let simRNG = null;

// Learner model state
let learnerSkills = {}; // per-pitch class skills [0..1]
let simConfusionMatrix = {}; // 12x12 confusion tracking

// Initialize learner skills
function initializeLearnerSkills() {
  learnerSkills = {};
  PC.forEach(pc => {
    learnerSkills[pc] = 0.55; // Initial skill level
  });
}

// Initialize simulation confusion matrix
function initializeSimConfusionMatrix() {
  simConfusionMatrix = {};
  PC.forEach(truePc => {
    simConfusionMatrix[truePc] = {};
    PC.forEach(guessPc => {
      simConfusionMatrix[truePc][guessPc] = 0;
    });
  });
}

// Learner model response
function simulateLearnerResponse(truePc, isOOB, jitterInfo) {
  if (isOOB) {
    // OOB trials: simulate realistic detection ability
    // Base OOB detection rate of 70%, with some variation based on skill level
    const avgSkill = Object.values(learnerSkills).reduce((a, b) => a + b, 0) / 12;
    const detectionRate = 0.65 + (avgSkill - 0.55) * 0.2; // Range: ~0.65-0.75
    const correctOOB = simRNG() < Math.max(0.5, Math.min(0.85, detectionRate));
    return { correct: correctOOB, guess: 'OOB' };
  }
  
  // Calculate base probability of correct response
  let base = learnerSkills[truePc] || 0.55;
  
  // Apply penalties/bonuses based on jitter
  if (jitterInfo.isProbe) {
    base -= 0.18; // Probe penalty (¬±25-40¬¢)
  } else if (jitterInfo.jitter !== 0) {
    const penalty = Math.min(Math.abs(jitterInfo.jitter) / 40, 0.12);
    base -= penalty; // Jitter penalty up to -0.12
  } else {
    base += 0.03; // Anchor bonus (0¬¢)
  }
  
  // Clamp probability
  base = Math.max(0.05, Math.min(0.98, base));
  
  // Determine if correct
  const correct = simRNG() < base;
  
  let guess = truePc;
  if (!correct) {
    // Choose incorrect guess using confusion distribution
    const confusionRow = simConfusionMatrix[truePc];
    const neighbors = getNeighboringSemitones(truePc);
    
    if (simRNG() < 0.5) {
      // 50% chance: prefer nearest semitones
      guess = neighbors[Math.floor(simRNG() * neighbors.length)];
    } else {
      // 50% chance: sample from confusion matrix
      const weights = PC.map(pc => (confusionRow[pc] || 0) + 0.01); // epsilon
      const totalWeight = weights.reduce((a, b) => a + b, 0);
      const rand = simRNG() * totalWeight;
      let cumulative = 0;
      for (let i = 0; i < PC.length; i++) {
        cumulative += weights[i];
        if (rand <= cumulative) {
          guess = PC[i];
          break;
        }
      }
    }
  }
  
  return { correct, guess };
}

// Get neighboring semitones for confusion
function getNeighboringSemitones(pc) {
  const idx = PC.indexOf(pc);
  const prev = PC[(idx + 11) % 12];
  const next = PC[(idx + 1) % 12];
  return [prev, next];
}

// Update learner skills after trial
function updateLearnerSkills(truePc, correct, guess) {
  const skill = learnerSkills[truePc];
  
  if (correct) {
    // Increase skill, with diminishing returns
    const increment = 0.01 * (1 - skill);
    learnerSkills[truePc] = Math.min(0.97, skill + increment);
  } else {
    // Decrease skill, with bonus penalty for nearby confusions
    let decrement = 0.005;
    const neighbors = getNeighboringSemitones(truePc);
    if (neighbors.includes(guess)) {
      decrement += 0.005; // Extra penalty for ¬±1 semitone errors
    }
    learnerSkills[truePc] = Math.max(0.40, skill - decrement);
  }
}

// Update confusion matrix
function updateSimConfusionMatrix(truePc, guess) {
  if (!simConfusionMatrix[truePc]) simConfusionMatrix[truePc] = {};
  simConfusionMatrix[truePc][guess] = (simConfusionMatrix[truePc][guess] || 0) + 1;
}

// Simulate cold/warm recall
// E) RECALL (COLD/WARM) - Simulate recall test with proper verdict format
function simulateRecall(type) {
  const learnedPcs = Object.keys(learnerSkills).filter(pc => learnerSkills[pc] > 0.55);
  const testPcs = learnedPcs.length >= 3 ? 
    shuffleArray(learnedPcs).slice(0, 3) : 
    learnedPcs;
  
  const results = testPcs.map(pc => {
    const skill = learnerSkills[pc];
    const meanError = (1 - skill) * 35; // Cents error mean
    const sdError = 12; // Standard deviation
    
    // Generate normal distribution error, clamped to ¬±60¬¢
    let error = normalRandom() * sdError + meanError;
    error = Math.max(-60, Math.min(60, error));
    
    const medianCents = Math.round(error * 10) / 10;
    const sdCents = Math.round(sdError * 10) / 10;
    
    // Calculate verdict: OnTarget (|median|‚â§10¬¢ & SD‚â§15¬¢), Close (|median|‚â§30¬¢), Off otherwise
    let verdict = "Off";
    if (Math.abs(medianCents) <= 10 && sdCents <= 15) {
      verdict = "OnTarget";
    } else if (Math.abs(medianCents) <= 30) {
      verdict = "Close";
    }
    
    return { 
      pc, 
      medianCents, 
      sdCents, 
      verdict 
    };
  });
  
  // Store in the enhanced recall format per day
  const currentDay = Math.floor((Date.now() - simStartTime) / (24 * 60 * 60 * 1000)) + 1;
  if (!state.recall[currentDay]) {
    state.recall[currentDay] = {};
  }
  state.recall[currentDay][type] = results;
  
  return results;
}

// Box-Muller normal distribution
function normalRandom() {
  const u1 = simRNG();
  const u2 = simRNG();
  return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
}

// Fisher-Yates shuffle using seeded RNG
function shuffleArray(array) {
  const arr = [...array];
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(simRNG() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

// Override Math.random during simulation
function withSimulatedRandom(fn) {
  if (!SIMULATING) return fn();
  
  const originalRandom = Math.random;
  Math.random = simRNG;
  try {
    return fn();
  } finally {
    Math.random = originalRandom;
  }
}

// Simulation wrapper functions to use existing implementations
function simSelectInBoundsNote(usable) {
  return withSimulatedRandom(() => {
    // Use the real selectInBoundsNote function which has proper logic
    return selectInBoundsNote(usable);
  });
}

function simSelectOctaveForNote(pc) {
  return withSimulatedRandom(() => {
    // Use existing octave selection logic if available
    if (typeof currentOctaves === 'function') {
      const octaves = currentOctaves();
      const weights = [0.15, 0.7, 0.15]; // Favor octave 4
      const rand = Math.random();
      let cumulative = 0;
      for (let i = 0; i < weights.length; i++) {
        cumulative += weights[i];
        if (rand <= cumulative) {
          return octaves[i] || (3 + i);
        }
      }
      return 4; // Fallback
    }
    // Fallback: weighted random from [3,4,5] with bias toward 4
    const weights = [0.15, 0.7, 0.15]; // Favor octave 4
    const rand = Math.random();
    let cumulative = 0;
    for (let i = 0; i < weights.length; i++) {
      cumulative += weights[i];
      if (rand <= cumulative) {
        return 3 + i;
      }
    }
    return 4; // Fallback
  });
}

function simInitializeJitterLevel(pc) {
  // Use existing jitter initialization logic
  return initializeJitterLevel(pc);
}

function simShouldUseProbe(pc) {
  return withSimulatedRandom(() => {
    // Use existing probe logic
    return shouldUseProbe(pc);
  });
}

function simCalculateJitter(pc, isProbe) {
  return withSimulatedRandom(() => {
    // Use existing jitter calculation
    return generateJitterForNote(pc, isProbe);
  });
}

// Simulate a single trial
function simulateTrial(set, blockNum, trialNum) {
  return withSimulatedRandom(() => {
    // Generate trial using existing logic
    const usable = trainedSet(set);
    const wasOOB = shouldGenerateOOB(set);
    
    let truePc, currentNote, jitterInfo;
    
    if (wasOOB) {
      truePc = selectOOBNote(set);
      // Use mirroring octave selection for OOB
      const octave = withSimulatedRandom(() => selectOctaveForOOBNote(truePc));
      currentNote = `${truePc}${octave}`;
      jitterInfo = { jitter: 0, isProbe: false, level: null };
    } else {
      truePc = simSelectInBoundsNote(usable);
      const octave = simSelectOctaveForNote(truePc);
      currentNote = `${truePc}${octave}`;
      
      // Initialize jitter level if needed
      simInitializeJitterLevel(truePc);
      
      // Use the new jitter system
      jitterInfo = withSimulatedRandom(() => getJitterInfo(truePc));
    }
    
    // Get learner response
    const response = simulateLearnerResponse(truePc, wasOOB, jitterInfo);
    
    // Record trial data
    const trialData = {
      day: Math.floor((Date.now() - simStartTime) / (24 * 60 * 60 * 1000)) + 1,
      block: blockNum,
      t: trialNum,
      pc: truePc,
      octave: parseInt(currentNote.slice(-1)),
      isOOB: wasOOB,
      detuneCents: Math.round(jitterInfo.jitter * 10) / 10,
      probe: jitterInfo.isProbe,
      anchor: jitterInfo.isAnchor || (jitterInfo.jitter === 0 && !wasOOB),
      ok: response.correct,
      guess: response.guess,  // Add the guess information
      currentNote: currentNote  // Add the full note name
    };
    
    // Update learner state for in-bounds trials
    if (!wasOOB) {
      updateLearnerSkills(truePc, response.correct, response.guess);
      if (!response.correct && response.guess !== truePc) {
        updateSimConfusionMatrix(truePc, response.guess);
      }
      
      // C) JITTER LADDER LOGGING - Check for promotion/demotion on every trial
      // Temporarily disable during checks to avoid recursion
      const originalSimulating = SIMULATING;
      SIMULATING = false;
      try {
        checkJitterPromotion(truePc);
        checkJitterDemotion(truePc);
      } finally {
        SIMULATING = originalSimulating;
      }
    }
    
    // Record in app state (simulate recordTrial call)
    // Set global variables that recordTrial depends on
    const origCurrentNote = typeof currentNote !== 'undefined' ? currentNote : null;
    const origTruePc = typeof truePc !== 'undefined' ? truePc : null;
    const origIsOOBTrial = typeof isOOBTrial !== 'undefined' ? isOOBTrial : null;
    const origCurrentTrialJitter = typeof currentTrialJitter !== 'undefined' ? currentTrialJitter : null;
    
    // Set simulation values
    window.currentNote = currentNote;
    window.truePc = truePc;
    window.isOOBTrial = wasOOB;
    window.currentTrialJitter = jitterInfo;
    
    try {
      recordTrial(response.guess, response.correct, false, wasOOB);
    } finally {
      // Restore original values
      if (origCurrentNote !== null) window.currentNote = origCurrentNote;
      if (origTruePc !== null) window.truePc = origTruePc;
      if (origIsOOBTrial !== null) window.isOOBTrial = origIsOOBTrial;
      if (origCurrentTrialJitter !== null) window.currentTrialJitter = origCurrentTrialJitter;
    }
    
    return trialData;
  });
}

// Track simulation start time
let simStartTime = 0;

// Main simulation function
window.runSimWeek = function(opts = {}) {
  const days = opts.days ?? 7;
  const seed = opts.seed ?? 1234;
  const dailyBlocks = opts.dailyBlocks ?? SIM_DAILY_BLOCKS;
  const trialsPerBlock = opts.trialsPerBlock ?? SIM_TRIALS_PER_BLOCK;
  
  // Initialize simulation
  SIMULATING = true;
  simRNG = mulberry32(seed);
  simStartTime = Date.now();
  
  // Initialize learner model
  initializeLearnerSkills();
  initializeSimConfusionMatrix();
  
  // Ensure octave state is properly initialized for simulation
  initializeOctaveState();
  
  // Predeclare output structure as required
  const out = { perDay: [], tones: [], trials: [], oobSeries: [] };
  
  // Save original state
  const originalState = JSON.parse(JSON.stringify(state));
  
  try {
    // Run simulation for each day
    for (let day = 1; day <= days; day++) {
      // Reset daily counters but keep cross-day state
      const dayStartMinutes = state.minutesToday || 0;
      
      let dayOobTrials = 0;
      let dayOobCorrect = 0;
      let dayOobMaxStreak = 0;
      let dayCurrentStreak = 0;
      let dayAnchors = 0;
      let dayProbes = 0;
      let dayJittered = 0;
      let dayTotalTrials = 0;
      
      const octaveCounts = {
        inBounds: { 3: 0, 4: 0, 5: 0 },
        oob: { 3: 0, 4: 0, 5: 0 }
      };
      
      // Track windowed octave gates (trials 8-12, 16-20, 20-24 per block) 
      const octaveWindows = [];
      let currentWindowTrials = [];
      
      // Simulate cold recall at start of day
      const coldRecall = simulateRecall('cold');
      
      // Run daily blocks
      for (let block = 1; block <= dailyBlocks; block++) {
        // A) OOB OCTAVE MIRRORING - Track block-level octave distributions
        const blockInBoundsOctaves = { 3: 0, 4: 0, 5: 0 };
        const blockOOBOctaves = { 3: 0, 4: 0, 5: 0 };
        let blockInBoundsCount = 0;
        let blockOOBCount = 0;
        
        for (let trial = 1; trial <= trialsPerBlock; trial++) {
          const set = setFromIndex(state.levelIndex);
          const globalBlock = (day - 1) * dailyBlocks + block;
          
          // Generate trial with the exact same policy code the live app uses
          const trialData = simulateTrial(set, block, trial);
          
          // Create tone record for QA exporters - match exact format from problem statement
          const detuneMode = trialData.isOOB ? "oob" : 
                      trialData.anchor ? "anchor" :
                      trialData.probe ? "probe" : "jitter";
          
          const toneRecord = {
            note: trialData.currentNote,
            pc: trialData.pc,
            oct: trialData.octave,
            cents: trialData.isOOB ? 0 : (trialData.detuneCents || 0),
            detuneMode: detuneMode, // Use detuneMode as specified in problem statement
            isOOB: trialData.isOOB,
            timbre: "piano", // Default timbre for simulation
            jl: trialData.isOOB ? null : (state.jitterLevels?.[trialData.pc] ?? 0) // JL level 0-3 for in-bounds tones
          };
          out.tones.push(toneRecord);
          
          // Create trial record for QA exporters
          const guessNote = trialData.isOOB ? "OOB" : `${trialData.guess}${trialData.octave}`;
          const trialRecord = {
            trueNote: trialData.currentNote,
            truePc: trialData.pc,
            guess: guessNote,
            guessPc: trialData.guess,
            correct: trialData.ok,
            oob: trialData.isOOB,
            rtMs: Math.round(300 + simRNG() * 1200) // Simulate reaction time 300-1500ms
          };
          out.trials.push(trialRecord);
          
          // Collect statistics (same as before)
          dayTotalTrials++;
          currentWindowTrials.push(trialData);
          
          // Check octave windows (trials 8-12, 16-20, 20-24)
          const trialInBlock = ((trial - 1) % trialsPerBlock) + 1;
          if ((trialInBlock >= 8 && trialInBlock <= 12) || 
              (trialInBlock >= 16 && trialInBlock <= 20) || 
              (trialInBlock >= 20 && trialInBlock <= 24)) {
            if (currentWindowTrials.length >= 5) { // Capture windows of 5 trials
              const windowOctaves = currentWindowTrials.slice(-5).map(t => t.octave);
              const centerCount = windowOctaves.filter(o => o === 4).length;
              const neighborCount = windowOctaves.filter(o => o !== 4).length;
              octaveWindows.push({
                block: block,
                window: `${trialInBlock-4}-${trialInBlock}`,
                centerCount: centerCount,
                neighborCount: neighborCount,
                centerRatio: centerCount / 5
              });
            }
          }
          
          if (trialData.isOOB) {
            dayOobTrials++;
            if (trialData.ok) dayOobCorrect++;
            dayCurrentStreak = trialData.ok ? 0 : dayCurrentStreak + 1;
            dayOobMaxStreak = Math.max(dayOobMaxStreak, dayCurrentStreak);
            octaveCounts.oob[trialData.octave]++;
            
            // A) OOB OCTAVE MIRRORING - Track OOB octaves for this block
            blockOOBOctaves[trialData.octave]++;
            blockOOBCount++;
          } else {
            dayCurrentStreak = 0;
            octaveCounts.inBounds[trialData.octave]++;
            
            // A) OOB OCTAVE MIRRORING - Track in-bounds octaves for this block
            blockInBoundsOctaves[trialData.octave]++;
            blockInBoundsCount++;
            
            if (trialData.anchor) dayAnchors++;
            else if (trialData.probe) dayProbes++;
            else if (trialData.detuneCents !== 0) dayJittered++;
          }
        }
        
        // A) OOB OCTAVE MIRRORING - Record block octave mirroring data
        if (blockInBoundsCount > 0 || blockOOBCount > 0) {
          const inBoundsFractions = { 3: 0, 4: 0, 5: 0 };
          const oobFractions = { 3: 0, 4: 0, 5: 0 };
          
          // Calculate in-bounds fractions
          if (blockInBoundsCount > 0) {
            inBoundsFractions[3] = blockInBoundsOctaves[3] / blockInBoundsCount;
            inBoundsFractions[4] = blockInBoundsOctaves[4] / blockInBoundsCount;
            inBoundsFractions[5] = blockInBoundsOctaves[5] / blockInBoundsCount;
          }
          
          // Calculate OOB fractions
          if (blockOOBCount > 0) {
            oobFractions[3] = blockOOBOctaves[3] / blockOOBCount;
            oobFractions[4] = blockOOBOctaves[4] / blockOOBCount;
            oobFractions[5] = blockOOBOctaves[5] / blockOOBCount;
          }
          
          // Calculate percentage point differences
          const diffPP = {
            3: num((oobFractions[3] - inBoundsFractions[3]) * 100, null),
            4: num((oobFractions[4] - inBoundsFractions[4]) * 100, null),
            5: num((oobFractions[5] - inBoundsFractions[5]) * 100, null)
          };
          
          // Store octave mirroring record
          const mirrorRecord = {
            block: (day - 1) * dailyBlocks + block,
            inb: {
              3: num(inBoundsFractions[3], 0),
              4: num(inBoundsFractions[4], 0),
              5: num(inBoundsFractions[5], 0)
            },
            oob: {
              3: num(oobFractions[3], 0),
              4: num(oobFractions[4], 0),
              5: num(oobFractions[5], 0)
            },
            diff_pp: diffPP
          };
          
          if (!state.oobOctaveMirror) state.oobOctaveMirror = [];
          state.oobOctaveMirror.push(mirrorRecord);
          
          // Also store in QA format for export
          const mirrorQARecord = {
            globalTimeBlockIndex: (day - 1) * dailyBlocks + block,
            inBounds: {3: blockInBoundsOctaves[3], 4: blockInBoundsOctaves[4], 5: blockInBoundsOctaves[5]},
            oob: {3: blockOOBOctaves[3], 4: blockOOBOctaves[4], 5: blockOOBOctaves[5]},
            diff_pp: diffPP
          };
          
          if (!state.qa.octaves.mirror) state.qa.octaves.mirror = [];
          state.qa.octaves.mirror.push(mirrorQARecord);
        }
        
        // Trigger block boundary logic when globalBlock % 3 === 0 (not local block)
        const globalBlock = (day - 1) * dailyBlocks + block;
        
        if (globalBlock % 3 === 0) {
          // Update counters to simulate proper time block progression
          
          // Update the centralized counters to reflect the current state
          state.counters.globalTimeBlockIndex = globalBlock;
          state.counters.inbTrialIndex = out.trials.filter(t => !t.oob && t.correct !== undefined).length;
          
          // Calculate last 60 in-bounds accuracy before adaptation
          const last60InBounds = out.trials
            .filter(t => !t.oob && t.correct !== undefined)
            .slice(-60);
          
          const last60Acc = last60InBounds.length > 0 ? 
            last60InBounds.filter(t => t.correct).length / last60InBounds.length : 0;
          
          // Call the real adaptation function with proper condition checking
          withSimulatedRandom(() => {
            // Check the proper conditions as in endTimeBlock()
            const shouldAdapt = (state.counters.globalTimeBlockIndex % 3 === 0) || 
                                (state.counters.inbTrialIndex - state.counters.lastOOBAdaptAt.inbTrialIndex >= 60);
            
            if (shouldAdapt) {
              adaptOOBTarget();
              state.counters.lastOOBAdaptAt.inbTrialIndex = state.counters.inbTrialIndex;
              state.counters.lastOOBAdaptAt.globalTimeBlockIndex = state.counters.globalTimeBlockIndex;
            }
          });
          
          const newRate = state.oobStats?.adaptiveRate ?? 0.18;
          
          // Push to oobSeries with FRACTION units (0..1)
          out.oobSeries.push({
            day: day,
            block: block,
            globalBlock: globalBlock,
            targetPct: newRate, // Store as fraction (0..1), not percentage
            last60Acc: last60Acc // Store as fraction (0..1), not percentage
          });
        }
      }
      
      // Simulate warm recall at end of day
      const warmRecall = simulateRecall('warm');
      
      // C) JITTER LADDER LOGGING - Generate daily snapshots
      generateDailyJitterSnapshot();
      
      // Calculate day statistics
      const oobTargetPct = state.oobStats?.adaptiveRate ?? 0.18; // Keep as fraction
      const oobObservedPct = dayOobTrials > 0 ? 
        dayOobTrials / dayTotalTrials : 0; // Keep as fraction
      
      // Store per-day summary in out.perDay
      out.perDay.push({
        inBoundsOctaves: octaveCounts.inBounds,
        oobOctaves: octaveCounts.oob,
        anchorsPct: dayTotalTrials > 0 ? dayAnchors / dayTotalTrials : 0,
        probesPct: dayTotalTrials > 0 ? dayProbes / dayTotalTrials : 0,
        jitterPct: dayTotalTrials > 0 ? dayJittered / dayTotalTrials : 0,
        oobObservedPct: oobObservedPct, // Store as fraction (0..1)
        maxOOBStreak: dayOobMaxStreak
      });
    }
    
    // Type hygiene: ensure jitterLevels are numeric 0..3, not "JL0" strings
    PC.forEach(pc => {
      if (typeof state.jitterLevels?.[pc] === 'string') {
        const level = parseInt(state.jitterLevels[pc].replace('JL', ''));
        state.jitterLevels[pc] = isNaN(level) ? 0 : Math.max(0, Math.min(3, level));
      }
    });
    
    // Type hygiene: activePitches should list the simulated set
    const set = setFromIndex(state.levelIndex);
    state.activePitches = trainedSet(set);
    
    // Calculate detuneShares with counts
    const totalTones = out.tones.length;
    const anchorCount = out.tones.filter(t => t.mode === 'anchor').length;
    const probeCount = out.tones.filter(t => t.mode === 'probe').length;
    const jitterCount = out.tones.filter(t => t.mode === 'jitter').length;
    const oobCount = out.tones.filter(t => t.mode === 'oob').length;
    
    out.detuneShares = {
      anchorCount,
      probeCount, 
      jitterCount,
      oobCount,
      anchorPct: totalTones > 0 ? Math.round((anchorCount / totalTones) * 1000) / 10 : 0,
      probePct: totalTones > 0 ? Math.round((probeCount / totalTones) * 1000) / 10 : 0,
      jitterPct: totalTones > 0 ? Math.round((jitterCount / totalTones) * 1000) / 10 : 0,
      oobPct: totalTones > 0 ? Math.round((oobCount / totalTones) * 1000) / 10 : 0
    };
    
    // Ensure all detuneCents are numeric (not null) in tones 
    out.tones.forEach(tone => {
      if (tone.cents === null || tone.cents === undefined) {
        tone.cents = 0;
      }
    });
    
    // Calculate total octave counts across all days for export
    const totalOctaveCounts = {
      inBounds: { 3: 0, 4: 0, 5: 0 },
      oob: { 3: 0, 4: 0, 5: 0 }
    };
    
    out.trials.forEach(trial => {
      const octave = trial.truePc ? parseInt(trial.trueNote?.slice(-1)) : null;
      if (octave >= 3 && octave <= 5) {
        if (trial.oob) {
          totalOctaveCounts.oob[octave]++;
        } else {
          totalOctaveCounts.inBounds[octave]++;
        }
      }
    });
    
    out.octaveCounts = totalOctaveCounts;
    
    // Add mirror data to simulation output
    out.octaveMirror = state.qa.octaves?.mirror || [];
    
    // Return the required structure
    return out;
    
  } finally {
    // Restore original state
    Object.assign(state, originalState);
    SIMULATING = false;
    simRNG = null;
  }
};

// Export simulation results to JSON file
window.exportSimWeek = async function(opts) {
  const results = await window.runSimWeek(opts);
  const dateStr = new Date().toISOString().slice(0, 10);
  const filename = `sim_week_${dateStr}.json`;
  
  const blob = new Blob([JSON.stringify(results, null, 2)], { 
    type: 'application/json' 
  });
  
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  a.click();
  
  setTimeout(() => URL.revokeObjectURL(a.href), 0);
  
  return results;
};

// Add jitter debug commands
window.debugJitter = function(pc = 'F') {
  console.log('=== JITTER DEBUG ===');
  initializeJitterLevel(pc);
  console.log(`Pitch: ${pc}`);
  console.log(`Level: JL${state.jitterLevels[pc] || 0}`);
  console.log(`Range: ${state.jitterRangeUsed[pc] || 'not set'}`);
  console.log(`Needs rescue: ${needsRescueMode(pc)}`);
  
  const rescueConfig = getRescueConfig(pc);
  if (rescueConfig) {
    console.log(`Rescue mode active:`, rescueConfig);
  }
  
  // Test anchor/probe rates
  let anchorTests = 0, probeTests = 0;
  for (let i = 0; i < 100; i++) {
    if (shouldUseAnchor(pc)) anchorTests++;
    if (shouldUseProbe(pc)) probeTests++;
  }
  console.log(`Anchor rate (100 tests): ${anchorTests}%`);
  console.log(`Probe rate (100 tests): ${probeTests}%`);
  
  // Test jitter generation
  const jitterSamples = [];
  for (let i = 0; i < 10; i++) {
    const info = getJitterInfo(pc);
    jitterSamples.push(info);
  }
  console.log('Sample jitter outputs:', jitterSamples);
};

// Generate OOB octave mix check data for export
function generateOOBOctaveMixCheck() {
  const today = new Date().toDateString();
  const todayTrials = state.trials.filter(t => new Date(t.time).toDateString() === today);
  
  const inBounds = { 3: 0, 4: 0, 5: 0 };
  const oob = { 3: 0, 4: 0, 5: 0 };
  
  todayTrials.forEach(trial => {
    if (trial.note) {
      const octave = parseInt(trial.note.slice(-1));
      if (octave >= 3 && octave <= 5) {
        if (trial.oob) {
          oob[octave]++;
        } else {
          inBounds[octave]++;
        }
      }
    }
  });
  
  return { inBounds, oob };
}

/* ------------------ DAILY BY-PITCH EXPORT ------------------ */
function generateDailyByPitchData() {
  const today = new Date().toDateString();
  const todayTrials = state.trials.filter(t => new Date(t.time).toDateString() === today);
  
  const byPitch = {};
  const pitchClasses = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];
  
  pitchClasses.forEach(pc => {
    const pcTrials = todayTrials.filter(t => t.pc === pc && !t.oob);
    
    if (pcTrials.length === 0) {
      byPitch[pc] = {
        attempts: 0,
        accuracy: 0,
        medianAbsCents: 0,
        jlLevel: state.jitterLevels[pc] || 0,
        anchorShare: 0,
        probeShare: 0,
        jitterShare: 0,
        currentJitterRangeUsed: state.jitterRangeUsed[pc] || '¬±3-8¬¢'
      };
      return;
    }
    
    const correct = pcTrials.filter(t => t.correct).length;
    const accuracy = correct / pcTrials.length;
    
    // Calculate median absolute cents error
    const centsErrors = pcTrials.map(t => Math.abs(t.detuneCents || 0));
    centsErrors.sort((a, b) => a - b);
    const medianAbsCents = centsErrors[Math.floor(centsErrors.length / 2)] || 0;
    
    // Calculate mode shares
    const anchorTrials = pcTrials.filter(t => t.detuneMode === 'anchor').length;
    const probeTrials = pcTrials.filter(t => t.detuneMode === 'probe').length;
    const jitterTrials = pcTrials.filter(t => t.detuneMode === 'jitter').length;
    
    byPitch[pc] = {
      attempts: pcTrials.length,
      accuracy: Math.round(accuracy * 1000) / 10, // 1 decimal place percentage
      medianAbsCents: Math.round(medianAbsCents * 10) / 10,
      jlLevel: state.jitterLevels[pc] || 0,
      anchorShare: Math.round((anchorTrials / pcTrials.length) * 1000) / 10,
      probeShare: Math.round((probeTrials / pcTrials.length) * 1000) / 10,
      jitterShare: Math.round((jitterTrials / pcTrials.length) * 1000) / 10,
      currentJitterRangeUsed: state.jitterRangeUsed[pc] || '¬±3-8¬¢'
    };
  });
  
  return byPitch;
}

// Export daily by-pitch data
window.exportDailyByPitch = function() {
  const data = generateDailyByPitchData();
  const dateStr = new Date().toISOString().slice(0, 10);
  const filename = `daily_by_pitch_${dateStr}.json`;
  
  const blob = new Blob([JSON.stringify(data, null, 2)], { 
    type: 'application/json' 
  });
  
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  a.click();
  URL.revokeObjectURL(a.href);
  
  console.log('Daily by-pitch data exported:', filename);
  return data;
};

/* ------------------ EXPORT FOR QA ------------------ */
function exportTrainingData() {
  try {
    // Generate comprehensive export data
    const exportData = {
      // Basic info
      userName: state.userName,
      startDate: state.startDate,
      exportDate: Date.now(),
      
      // Calculate days since start
      days: state.startDate ? Math.floor((Date.now() - state.startDate) / (24 * 60 * 60 * 1000)) + 1 : 0,
      
      // Per-day aggregated data
      perDay: generatePerDayData(),
      
      // NEW: Daily by-pitch data
      byPitch: generateDailyByPitchData(),
      
      // NEW: OOB octave mix verification
      oobOctaveMixCheck: generateOOBOctaveMixCheck(),
      
      // OOB adaptation series
      oobSeries: state.oobSeries || [],
      
      // Octave window metrics
      octaveWindowMetrics: state.octaveWindowMetrics || [],
      
      // Per-pitch statistics
      perPitch: generatePerPitchStats(),
      
      // 12x12 confusion matrix
      confusionMatrix: state.confusionMatrix || {},
      
      // Selection weights trace
      weightsTrace: state.weightsTrace || [],
      
      // Cold/warm recall results
      recall: state.recallResults || [],
      
      // Assessment scores
      assessmentScores: state.assessmentScores || [],
      
      // Raw trial data (last 1000 trials for QA)
      rawTrials: state.trials ? state.trials.slice(-1000) : []
    };
    
    // Create downloadable file
    const blob = new Blob([JSON.stringify(exportData, null, 2)], { 
      type: 'application/json' 
    });
    
    const dateStr = new Date().toISOString().slice(0, 10);
    const filename = `pitch_training_${state.userName}_${dateStr}.json`;
    
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    a.click();
    
    setTimeout(() => URL.revokeObjectURL(a.href), 0);
    
    alert(`Data exported successfully as ${filename}`);
    
  } catch (error) {
    alert(`Export failed: ${error.message}`);
    report(error);
  }
}

function generatePerDayData() {
  if (!state.trials || !state.startDate) return [];
  
  const perDayData = [];
  const startDay = dateAtMidnight(state.startDate);
  const today = dateAtMidnight(Date.now());
  
  for (let day = 0; day <= 6; day++) { // Week 1 (first 7 days)
    const dayStart = startDay + (day * 24 * 60 * 60 * 1000);
    const dayEnd = dayStart + (24 * 60 * 60 * 1000);
    
    if (dayStart > today) break; // Future day
    
    const dayTrials = state.trials.filter(t => 
      t.time >= dayStart && t.time < dayEnd
    );
    
    const inBoundsTrials = dayTrials.filter(t => !t.oob);
    const oobTrials = dayTrials.filter(t => t.oob);
    const probeTrials = dayTrials.filter(t => t.jitter && t.jitter.isProbe);
    const anchorTrials = dayTrials.filter(t => t.jitter && t.jitter.isAnchor);
    
    // Calculate octave distribution
    const octaveCounts = {
      inBounds: { 3: 0, 4: 0, 5: 0 },
      oob: { 3: 0, 4: 0, 5: 0 }
    };
    
    dayTrials.forEach(t => {
      if (t.note) {
        const octave = parseInt(t.note.slice(-1));
        if (octave >= 3 && octave <= 5) {
          if (t.oob) {
            octaveCounts.oob[octave]++;
          } else {
            octaveCounts.inBounds[octave]++;
          }
        }
      }
    });
    
    // Get recall data for this day
    const dayRecalls = state.recallResults.filter(r => 
      dateAtMidnight(r.date) === dayStart
    );
    const coldRecall = dayRecalls.find(r => r.type === 'cold');
    const warmRecall = dayRecalls.find(r => r.type === 'warm');
    
    perDayData.push({
      day: day + 1,
      date: dayStart,
      totalTrials: dayTrials.length,
      inBoundsTrials: inBoundsTrials.length,
      oobTrials: oobTrials.length,
      probesPct: dayTrials.length > 0 ? Math.round((probeTrials.length / dayTrials.length) * 100 * 10) / 10 : 0,
      anchorsPct: dayTrials.length > 0 ? Math.round((anchorTrials.length / dayTrials.length) * 100 * 10) / 10 : 0,
      octaveCounts: octaveCounts,
      cold: coldRecall || null,
      warm: warmRecall || null
    });
  }
  
  return perDayData;
}

function generatePerPitchStats() {
  const perPitchStats = {};
  
  PC.forEach(pc => {
    const pcTrials = state.trials.filter(t => t.pc === pc && !t.oob);
    if (pcTrials.length === 0) return;
    
    const probeTrials = pcTrials.filter(t => t.jitter && t.jitter.isProbe);
    const anchorTrials = pcTrials.filter(t => t.jitter && t.jitter.isAnchor);
    const jitteredTrials = pcTrials.filter(t => t.jitter && t.jitter.jitter !== 0 && !t.jitter.isProbe && !t.jitter.isAnchor);
    
    const centsErrors = pcTrials.map(t => Math.abs(t.jitter?.jitter || 0));
    const medianCents = centsErrors.length > 0 ? 
      centsErrors.sort((a, b) => a - b)[Math.floor(centsErrors.length / 2)] : 0;
    
    perPitchStats[pc] = {
      totalTrials: pcTrials.length,
      accuracy: pcTrials.length > 0 ? pcTrials.filter(t => t.correct).length / pcTrials.length : 0,
      probesPct: Math.round((probeTrials.length / pcTrials.length) * 100 * 10) / 10,
      anchorsPct: Math.round((anchorTrials.length / pcTrials.length) * 100 * 10) / 10,
      jitteredPct: Math.round((jitteredTrials.length / pcTrials.length) * 100 * 10) / 10,
      medianCents: Math.round(medianCents * 10) / 10,
      currentJitterLevel: state.jitterLevels?.[pc] || 'JL0'
    };
  });
  
  return perPitchStats;
}

/* ------------------ QA EXPORT FULL ------------------ */
// Add QA export API for verification tools
window.QA = window.QA || {};

// EXPORT API (for QA/tools) - Implement QA.exportFull as specified
window.QA.exportFull = function(opts = {}) {
  // Allow passing simulation data for analysis
  const simData = opts.simData;
  
  let totalTrials, totalTones, trialsData, tonesData;
  
  if (simData) {
    // Use simulation data
    totalTrials = simData.trials?.length || 0;
    totalTones = simData.tones?.length || 0;
    trialsData = simData.trials || [];
    tonesData = simData.tones || [];
  } else {
    // Use live state data
    totalTrials = state.trials.length;
    totalTones = state.tones?.length || 0; // FIX 1: Use real tones array
    trialsData = state.trials;
    tonesData = state.tones || [];
  }
  
  // Calculate OOB metrics
  const oobTrials = trialsData.filter(t => t.oob);
  const oobCorrect = oobTrials.filter(t => t.correct).length;
  const observedPct = totalTrials > 0 ? 
    num(oobTrials.length / totalTrials, 0) : 0;
  
  // Calculate max OOB streak
  let maxStreak = 0;
  let currentStreak = 0;
  trialsData.forEach(trial => {
    if (trial.oob) {
      currentStreak++;
      maxStreak = Math.max(maxStreak, currentStreak);
    } else {
      currentStreak = 0;
    }
  });
  
  // Calculate last 60 in-bounds accuracy
  const last60InBounds = trialsData.filter(t => !t.oob && t.correct !== undefined).slice(-60);
  const last60Acc = last60InBounds.length > 0 ? 
    num(last60InBounds.filter(t => t.correct).length / last60InBounds.length, 0) : 0;
  
  return {
    counts: { 
      tones: totalTones, 
      trials: totalTrials 
    },
    oob: { 
      series: state.qa.oob.series || [], 
      observedPct: observedPct, 
      maxStreak: maxStreak, 
      last60Acc: last60Acc 
    },
    octaves: { 
      inBounds: simData ? (simData.octaveCounts?.inBounds || { 3: 0, 4: 0, 5: 0 }) : (state.octaveStats?.inBounds || { 3: 0, 4: 0, 5: 0 }), 
      oob: simData ? (simData.octaveCounts?.oob || { 3: 0, 4: 0, 5: 0 }) : (state.octaveStats?.oob || { 3: 0, 4: 0, 5: 0 }), 
      mirror: simData ? (simData.octaveMirror || []) : (state.qa.octaves.mirror || [])
    },
    detune: { 
      shares: state.qa.detune.shares || { counts: { anchors: 0, probes: 0, jitter: 0, total: 0 }, pct: {} },
      byPitch: state.qa.detune.byPitch || {}
    },
    jitter: { 
      levels: state.qa.jitter.levels || {}, 
      levelEvents: state.qa.jitter.levelEvents || []
    },
    confusion: { 
      matrix: state.qa.confusion.matrix || {}
    },
    curriculum: state.qa.curriculum || { active: [], weights: {}, events: [] },
    tails: { 
      tones: simData ? simData.tones?.slice(-400) || [] : tonesData.slice(-400), 
      trials: trialsData.slice(-400)
    }
  };
};
    /* ------------------ QA EXPORT FUNCTIONS ------------------ */
// One-shot QA export function as requested
window.qaExportFull = function(options = {}) {
  const label = options.label || 'qa_export';
  
  // Get OOB series data with block indices
  const oobSeries = (state.oobSeries || []).map(entry => ({
    blockIndex: entry.blockIndex,
    block: blockFromIndex(entry.blockIndex),
    observedAcc60: entry.observedAcc60,
    targetPct: entry.targetPct,
    reason: entry.reason,
    timestamp: entry.timestamp
  }));
  
  // Get in-bounds octave tallies
  const inBoundsOctaveTallies = {
    cumulative: state.qa?.octaves?.inBounds || { 3: 0, 4: 0, 5: 0 },
    lastWindow: state.qa?.octaves?.lastInBoundsWindow || { 3: 0, 4: 0, 5: 0 },
    windowTrialsCount: state.qa?.octaves?.inBoundsWindowTrials?.length || 0
  };
  
  // Get detune type counts and offsets
  const detuneData = {
    typeCounts: state.detune?.shares || { anchor: 0, jitter: 0, probe: 0, oob: 0 },
    recentOffsets: state.trials.slice(-100).filter(t => t.cents !== null).map(t => ({
      cents: t.cents,
      detuneMode: t.detuneMode,
      jlLevel: t.jlLevel,
      block: t.block
    }))
  };
  
  // Get per-pitch JL data
  const perPitchJL = {};
  PC.forEach(pc => {
    if (state.jitter?.perPitch?.[pc] || state.jitterLevels?.[pc] !== undefined) {
      perPitchJL[pc] = {
        currentJL: state.jitterLevels?.[pc] ?? 0,
        persistedJL: state.jitter?.levels?.[pc] ?? 0,
        accuracy: state.jitter?.perPitch?.[pc]?.accuracy ?? 0,
        medianCents: state.jitter?.perPitch?.[pc]?.medianCents ?? 0,
        sdCents: state.jitter?.perPitch?.[pc]?.sdCents ?? 0,
        trialCount: state.jitter?.perPitch?.[pc]?.lastNTrials?.length ?? 0
      };
    }
  });
  
  // Get rolling window stats used for JL and OOB decisions
  const rollingWindowStats = {
    jlPromotionRules: JITTER_PROMOTION_RULES,
    jlDemotionRules: JITTER_DEMOTION_RULES,
    oobAdaptationStats: {
      currentRate: state.oobStats?.adaptiveRate ?? 0.18,
      adaptationCount: state.oobStats?.adaptationCount ?? 0,
      lastAdaptedBlock: state.oobStats?.lastAdaptedBlock,
      recentTrialsCount: state.oobStats?.recentTrials?.length ?? 0
    },
    last60InBoundsTrials: state.trials
      .filter(t => !t.oob && t.correct !== undefined)
      .slice(-60).length
  };
  
  // Get mirror check data
  const mirrorChecks = state.qa?.octaves?.mirrorCheck || [];
  
  const exportData = {
    label: label,
    timestamp: Date.now(),
    exportTime: new Date().toISOString(),
    currentLevel: state.levelIndex,
    currentSet: setFromIndex(state.levelIndex),
    currentBlock: blockFromIndex(state.levelIndex),
    
    // OOB series with block indices
    oobSeries: oobSeries,
    
    // In-bounds octave tallies
    inBoundsOctaves: inBoundsOctaveTallies,
    
    // Detune type counts and offsets
    detune: detuneData,
    
    // Per-pitch JL data
    perPitchJL: perPitchJL,
    
    // Rolling window stats used for decisions
    rollingWindowStats: rollingWindowStats,
    
    // Mirror check data (single check per block)
    mirrorChecks: mirrorChecks.slice(-20), // Last 20 checks
    
    // Summary stats
    summary: {
      totalTrials: state.trials.length,
      totalInBounds: state.trials.filter(t => !t.oob).length,
      totalOOB: state.trials.filter(t => t.oob).length,
      recentAccuracy: state.trials.slice(-60).filter(t => t.correct !== undefined).length > 0 
        ? state.trials.slice(-60).filter(t => t.correct !== undefined && t.correct).length / 
          state.trials.slice(-60).filter(t => t.correct !== undefined).length 
        : 0
    }
  };
  
  // Log and return the data
  console.log(`üéµ QA Export (${label}):`, exportData);
  
  // Also download as JSON file
  const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `huh_qa_export_${label}_${Date.now()}.json`;
  a.click();
  URL.revokeObjectURL(url);
  
  return exportData;
};

/* ------------------ INIT ------------------ */
// Log dev functions availability for confirmation
console.log('üéµ Dev functions available:');
console.log('- runSimWeek:', typeof window.runSimWeek === 'function' ? '‚úÖ available' : '‚ùå NOT AVAILABLE');
console.log('- exportSimWeek:', typeof window.exportSimWeek === 'function' ? '‚úÖ available' : '‚ùå NOT AVAILABLE');
console.log('- exportDailyByPitch:', typeof window.exportDailyByPitch === 'function' ? '‚úÖ available' : '‚ùå NOT AVAILABLE');
console.log('- debugJitter:', typeof window.debugJitter === 'function' ? '‚úÖ available' : '‚ùå NOT AVAILABLE');
console.log('- QA.exportFull:', typeof window.QA?.exportFull === 'function' ? '‚úÖ available' : '‚ùå NOT AVAILABLE');
console.log('- qaExportFull:', typeof window.qaExportFull === 'function' ? '‚úÖ available' : '‚ùå NOT AVAILABLE');

window.addEventListener('load', wireOnce);
window.addEventListener('resize', ()=>{ try{ drawChart(); }catch(_){ }});
</script>
</body>
</html>
